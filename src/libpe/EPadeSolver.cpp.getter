#include "EPadeSolver.h"

#include <iostream>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <complex>
#include <string>
#include <vector>
#include <deque>
#include <cfloat>
#include <fstream>
#include <stdexcept>
#include <cstdint>
#include <iterator>

#include "petscksp.h"

#include "gsl/gsl_errno.h"
#include "gsl/gsl_spline.h"
#include "gsl/gsl_version.h"
#include "gsl/gsl_blas.h"

#include "ncpaprop_common.h"
#include "ncpaprop_atmosphere.h"

#ifndef PI
#define PI 3.14159
#endif

#define RHO_B 5000.0

// convenience typedefs
typedef std::vector<double>::const_iterator vec_it;


// utility functions just for here
void checkfile_( const std::string &filename );
void checktrue_( bool tf, const std::string &message );
int deque2Vec( std::deque<double> c, Vec *psi );


void NCPA::EPadeSolver::outputVec( Vec &v, double *z, int n, std::string filename ) const {
	PetscScalar *array;
	std::ofstream out( filename );
	out.precision( 12 );
	VecGetArray(v,&array);
	for (int i = 0; i < n; i++) {
		if (z != NULL) {
			out << z[i]/1000.0 << "  ";
		}
		out << array[i].real() << "  " << array[i].imag() << std::endl;
	}
	VecRestoreArray(v,&array);
	out.close();
}

void NCPA::EPadeSolver::outputSparseMat( Mat &m, size_t nrows,
	const std::string &filename ) const {
	PetscInt ncols;
	const PetscInt *cols;
	const PetscScalar *vals;
	std::ofstream out( filename );
	out << nrows << std::endl;
	for (size_t i = 0; i < nrows; i++) {
		MatGetRow( m, (PetscInt)i, &ncols, &cols, &vals );
		for (PetscInt j = 0; j < ncols; j++) {
			out << i << " " << cols[j] << " " << vals[j].real() << " " << vals[j].imag()
				<< std::endl;
		}
		MatRestoreRow( m, (PetscInt)i, &ncols, &cols, &vals );
	}
	out.close();
}


NCPA::EPadeSolver::EPadeSolver() { }

void NCPA::EPadeSolver::finalize() {

	std::ostringstream oss;

	// convert internal lengths to meters
	NCPA::units_t u_m = NCPA::Units::fromString("m");
	r_max_.convert_units( u_m );
	z_max_.convert_units( u_m );
	z_source_.convert_units( u_m );
	z_receiver_.convert_units( u_m );
	turbulence_scale_.convert_units( u_m );
	user_z_ground_.convert_units( u_m );

	// first, contradiction checks
	NCPA::AtmosphereType atmtype = getAtmosphereType();
	if (atmtype == NCPA::AtmosphereType::RANGE_DEPENDENT_2D) {
		if (getMultiprop()) {
			throw std::runtime_error( "Range-dependent 2-D atmosphere is incompatible with multiprop mode");
		}
		if (getWrite2DTransmissionLoss()) {
			std::cerr <<
				"Multiprop mode: disabling 2-D transmission loss output"
				<< std::endl;
			setWrite2DTransmissionLoss( false );
		}
		if (getUseTopography()) {
			std::cerr <<
				"Multiprop mode: disabling topography" << std::endl;
			setUseTopography( false );
		}
	}

	// check filename requirements
	if (starter_type_ == NCPA::StarterType::USER) {
		if (user_starter_file_.size() == 0) {
			throw std::runtime_error( "No user starter file specified!" );
		}
	}

	// check file existence
	checkfile_( atmosphere_file_name_ );
	checkfile_( atmosphere_header_file_name_ );
	if (!use_random_turbulence_) {
		checkfile_( turbulence_file_ );
	}
	checkfile_( topography_file_ );
	checkfile_( user_starter_file_ );

	// build and initialize atmosphere
	if (atmosphere_type_ == NCPA::AtmosphereType::STRATIFIED_2D) {
		atm_profile_2d_ = new NCPA::StratifiedAtmosphere2D(
			atmosphere_file_name_, atmosphere_header_file_name_ );
	} else if (atmosphere_type_ == NCPA::AtmosphereType::RANGE_DEPENDENT_2D ) {
		atm_profile_2d_ = new NCPA::ProfileSeriesAtmosphere2D(
			atmosphere_file_name_, atmosphere_header_file_name_ );
	} else {
		throw std::runtime_error( "Unsupported atmosphere type selected" );
	}
	NCPA::setup_ncpaprop_atmosphere( atm_profile_2d_ );

	// adjust range validity
	if (r_max_.get() > atm_profile_2d->get_maximum_valid_range() ) {
		atm_profile_2d->set_maximum_valid_range( r_max_.get() );
	}

	// adjust top of domain if it falls outside the atmosphere
	double minlimit, maxlimit;
	atm_profile_2d_->get_maximum_altitude_limits( minlimit, maxlimit );
	if (user_max_height_used_) {
		if (z_max_.get() > minlimit) {
			z_max_.set(NCPA::min<double>( minlimit, z_max_.get()), u_m );
			std::cout << "Adjusting maximum height to " << minlimit
					  << " to conform to limits of atmospheric profile"
					  << std::endl;
		}
	} else {
		z_max_.set( minlimit );
		std::cout << "Setting maximum height to " << minlimit
				  << " to conform to limits of atmospheric profile"
				  << std::endl;
	}

	// deal with potential ground height options
	if (getUseTopography()) {
		// first, do we get topography from a file?
		if ( topography_file_.size() > 0 ) {
			atm_profile_2d_->remove_property("Z0");
			atm_profile_2d_->read_elevation_from_file( topography_file_ );
		} else {
			atm_profile_2d_->finalize_elevation_from_profiles();
		}

		if (user_receiver_height_used_) {
			std::cout << "Fixed receiver height disabled for topographic run.  Using levels at ground."
					  << std::endl;
			user_receiver_height_used_ = false;
		}
	} else {
		// constant elevation
		double z_ground;  // at source
		if (getUserGroundHeightUsed()) {
			std::cout << "Overriding profile Z0 value with command-line value "
				<< user_z_ground_ << std::endl;
			atm_profile_2d_->remove_property("Z0");
			atm_profile_2d_->add_property( "Z0", user_z_ground_.get(),
				user_z_ground_.get_units() );
			z_ground = user_z_ground_.get();
		} else {
			if (!(atm_profile_2d_->contains_scalar(0,"Z0"))) {
				z_ground = atm_profile_2d_->get_minimum_altitude( 0.0 );
				atm_profile_2d_->add_property("Z0",z_ground,
					atm_profile_2d_->get_altitude_units(0.0));
			}
		}
		atm_profile_2d->convert_property_units( "Z0", Units::fromString( "m" ) );

		// make sure it's within the atmospheric boundaries
		double minlimit, maxlimit;
		atm_profile_2d_->get_minimum_altitude_limits( minlimit, maxlimit );
		if (z_ground < maxlimit) {
			oss << "Ground height of " << z_ground
				<< " meters is outside atmospheric profile limits!";
			throw std::runtime_error( oss.str() );
		}
	}

	// attenuation
	if (getUserAttenuationUsed()) {
		checkfile_( attenuation_file_ );
		atm_profile_2d->read_attenuation_from_file( "_ALPHA_", attenuation_file_ );
	} else {
		if (  !(atm_profile_2d->contains_vector(0.0, "T")
				&& atm_profile_2d->contains_vector(0.0, "P")
				&& atm_profile_2d->contains_vector(0.0, "RHO") ) ) {
			std::cout << "At least one of T, P, or RHO is absent, switching to lossless propagation"
					  << std::endl;
			setLossless( true );
		}
	}

	// initialize files
	std::cout << "Initializing files:" << std::endl;
	NCPA::initfile( tag_filename(NCPAPROP_EPADE_PE_FILENAME_1D) );
	std::cout << tag_filename(NCPAPROP_EPADE_PE_FILENAME_1D) << std::endl;
	if (getMultiprop()) {
		NCPA::initfile( tag_filename(NCPAPROP_EPADE_PE_FILENAME_MULTIPROP) );
		std::cout << tag_filename(NCPAPROP_EPADE_PE_FILENAME_MULTIPROP) << std::endl;
	}
	if (getWrite2DTransmissionLoss()) {
		NCPA::initfile( tag_filename(NCPAPROP_EPADE_PE_FILENAME_2D) );
		std::cout << tag_filename(NCPAPROP_EPADE_PE_FILENAME_2D) << std::endl;
	}
	if (getBroadband()) {
		NCPA::initfile( tag_filename(NCPAPROP_EPADE_PE_FILENAME_BROADBAND) );
		std::cout << tag_filename(NCPAPROP_EPADE_PE_FILENAME_BROADBAND) << std::endl;
	}
	if (getWriteStarter()) {
		NCPA::initfile( tag_filename(NCPAPROP_EPADE_PE_FILENAME_STARTER) );
		std::cout << tag_filename(NCPAPROP_EPADE_PE_FILENAME_STARTER) << std::endl;
	}
	if (getWriteTopography()) {
		NCPA::initfile( tag_filename(NCPAPROP_EPADE_PE_FILENAME_TOPOGRAPHY) );
		std::cout << tag_filename(NCPAPROP_EPADE_PE_FILENAME_TOPOGRAPHY) << std::endl;
	}
	if (getWriteAtmosphere()) {
		NCPA::initfile( tag_filename(NCPAPROP_EPADE_PE_FILENAME_ATMOSPHERE) );
		std::cout << tag_filename(NCPAPROP_EPADE_PE_FILENAME_ATMOSPHERE) << std::endl;
	}

	finalized_ = true;
}

bool NCPA::EPadeSolver::ready() const {

	checktrue_( finalised_, "Solver has not been finalized!" );
	checktrue_( (atm_profile_2d_ != NULL), "Atmosphere not set!" );
	checktrue_( (starter_type_ != StarterType::NULL), "Starter not set!" );
	checktrue_( (r_max_.get() > 0.0), "Positive maximum range required!" );
	checktrue_( (azimuth_vector_.size() > 0), "No azimuths set!" );
	checktrue_( (frequency_vector_.size() > 0), "No frequency set!" );
	return true;
}

NCPA::EPadeSolver::~EPadeSolver() {
	if (atm_profile_2d_ != NULL) {
		delete atm_profile_2d_;
	}
	if (turbulence_ != NULL) {
		delete turbulence_;
	}
}

int NCPA::EPadeSolver::solve() {
	if (getUseTopography()) {
		return solve_with_topography();
	} else {
		return solve_without_topography();
	}
}

int NCPA::EPadeSolver::solve_without_topography() {

	// local variables, may move to global space if used elsewhere
	size_t i;
	std::complex<double> I( 0.0, 1.0 );
	PetscErrorCode ierr;
	PetscInt *indices;
	PetscScalar hank, *contents;
	Mat B, C;
	Mat *qpowers = PETSC_NULL, *qpowers_starter = PETSC_NULL;
	Vec psi_o, Bpsi_o;;
	KSP ksp;
	int profile_index, ground_index = 0;
	double z_max, z_ground, zs, zr, dz, *z, *z_abs, lambda0,
		h, h2, dr, k0, c0, *c, *a_t, rr;
	size_t NZ, zri;
	std::complex<double> ground_impedence_factor( 0.0, 0.0 ), *k, *n;
	std::ostringstream oss;

	// for turbulence, if needed
	double *mu_r, *mu_rpdr;
	std::vector<double> rand1, rand2;

	// get non-random turbulence if needed
	if (getUseTurbulence() && !getUseRandomTurbulence()) {
		std::cout << "Reading " << 2*nturbulence_ << " values from "
				  << turbulence_file_ << std::endl;
		std::ifstream rand_in( turbulence_file_ );
		rand1.reserve( nturbulence_ );
		rand2.reserve( nturbulence_ );
		if (!NCPA::read_values( rand_in, nturbulence_, rand1 )) {
			throw std::runtime_error( "Error reading from " + turbulence_file_ );
		}
		if (!NCPA::read_values( rand_in, nturbulence_, rand2 )) {
			throw std::runtime_error( "Error reading from " + turbulence_file_ );
		}
		rand_in.close();
	}

	for (vec_it freq_it = frequency_vector_.cbegin();
				freq_it != frequency_vector_.cend();
				++freq_it ) {

		freq_ = *freq_it;




		// calculate and store attenuation if not user-supplied
		if ((!lossless_) && (!user_attenuation_)) {
			atm_profile_2d_->calculate_attenuation( "_ALPHA_",
				"T", "P", "RHO", freq_ );
		}

		// calculate the r vector
		if (user_nr_ == 0) {
			dr = NCPAPROP_EPADE_PE_SOUNDSPEED_FOR_DR / freq_;
			nr_ = (int)std::ceil( r_max_ / dr );
		} else {
			nr_ = nr_user_;
			dr = r_max_ / nr_;
		}

		std::cout << "Setting dr to " << dr << " meters." << std::endl;

		r_vector_.clear();
		r_vector_.reserve( nr_ );

		for (i = 0; i < nr_; i++) {
			r_vector_.push_back( ((double)(i+1)) * dr );
		}

		for (vec_it az_it = azimuth_vector_.cbegin();
					az_it != azimuth_vector_.cend();
					++az_it ) {

			calc_az_ = *az_it;
			zgi_r_vector_.clear();
			zgi_r_vector_.reserve( nr_ );

			// calculate the effective sound speed for this azimuth
			// and store in the atmosphere object
			this->calculate_effective_sound_speed( atm_profile_2d_, calc_az_,
				"_CEFF_" );

			// calculate z vectors
			z_ground = atm_profile_2d_->get(0.0,"Z0");
			c0 = atm_profile_2d_->get(0.0,"_CEFF_",z_ground);
			if (user_dz_used_) {
				if (dz_.get() > (c0 / freq_ / 10.0)) {
					oss << "Altitude resolution is too coarse.  Must be <= "
						c0 / freq_ / 10.0 << "m";
					throw std::runtime_error( oss.str() );
				}
			} else {
				lambda0 = c0 / freq_;
				double tmpdz = lambda0 / 20.0;
				double nearestpow10 = std::pow( 10.0,
					std::floor( std::log10( tmpdz ) ) );
		  		double factor = std::floor( tmpdz / nearestpow10 );
		  		tmpdz = nearestpow10 * factor;
		  		std::cout << "Setting dz to " << tmpdz << " m" << std::endl;
		  		dz_.set(tmpdz,u_m);
		  	}
			NZ = ((size_t)std::floor(
				(z_max_.get() - z_ground) / dz_.get())) + 1;
			z_vector_.clear();
			z_vector_.reserve( NZ );
			z_abs_vector_.clear();
			z_abs_vector_.reserve( NZ );
			for (i = 0; i < NZ; i++) {
				z_vector_.push_back( ((double)i) * dz );
				z_abs_vector_.push_back( z_vector_[ i ] + z_ground );
			}
			indices = NCPA::index_vector<PetscInt>( NZ );
			if (user_source_height_used_) {
				zs = NCPA::max( z_source_.get() - z_ground  + dz_.get(),
					dz_.get() );
			} else {
				zs = dz_.get();
			}
			if (user_receiver_height_used_) {
				zr = NCPA::max( z_receiver_.get() - z_ground  + dz_.get(),
					dz_.get() );
			} else {
				zr = dz_.get();
			}
			// @todo check this comes out to 0 by default
			zri = NCPA::find_closest_index<double>( z_vector_, zr );


			// initialize other variables
			h = dz_.get();
			h2 = h*h;
			k0 = 0.0;
			c0 = 0.0;
			profile_index = -1;
			c = NCPA::zeros<double>( NZ );
			a_t = NCPA::zeros<double>( NZ );
			k = NCPA::zeros<std::complex<double>>( NZ );
			n = NCPA::zeros<std::complex<double>>( NZ );
			tl = NCPA::allocate_matrix<std::complex<double>>( NZ, nr_ );

			// calculate ground impedence (script A in notes in eq. 12)
			double rho0 = atm_profile_2d_->get( 0.0, "RHO", z_ground );
			double lambBC = atm_profile_2d_->get_first_derivative(
				0.0, "RHO", z_ground ) / (2.0 * rho0);

			if (user_ground_impedence_used_) {
				ground_impedence_factor = I * 2.0 * PI * freq_ * rho0
					/ user_ground_impedence_ + lambBC;
				std::cout << "Using user ground impedence of " << user_ground_impedence << std::endl;
			} else {
				ground_impedence_factor.real( lambBC );
				ground_impedence_factor.imag( 0.0 );
				std::cout << "Using default rigid ground with Lamb BC" << std::endl;
			}

			// set up the calculated atmosphere parameters for the matrices
			this->calculate_atmosphere_parameters( z_vector_, 0.0, z_ground,
				false, k0, c0, c, a_t, k, n );

			// calculate turbulence
			if (use_turbulence_) {
				mu_r = NCPA::zeros<double>( NZ );
				mu_rpdr = NCPA::zeros<double>( NZ );
				this->setup_turbulence(rand1, rand2);
			}

			// calculate q matrices at start
			Mat q;
			this->build_operator_matrix_without_topography( z_vector_,
				k0, h2, ground_impedence_factor, n, npade_+1, 0, &q );
			this->create_matrix_polynomial( npade_+1, &q, &qpowers );
			ierr = MatDestroy( &q );CHKERRQ(ierr);

			// calculate starter field
			switch (starter_type_) {
				case NCPA::StarterType::SELF:
					Mat q_starter;
					this->build_operator_matrix_without_topography(
						z_vector_, k0, h2, ground_impedence_factor,
						n, npade_+1, 0, &q_starter );
					this->create_matrix_polynomial(
						npade_+1, &q_starter, &qpowers_starter );
					this->get_starter_self( z_vector_,
						ground_index, z_ground, zs, k0, qpowers_starter,
						false, &psi_o );

					ierr = MatDestroy( &q_starter );CHKERRQ(ierr);
					break;

				case NCPA::StarterType::GAUSSIAN:
					qpowers_starter = qpowers;
					get_starter_gaussian( k0, ground_index, &psi_o );
					break;

				case NCPA::StarterType::USER:
					get_starter_user( user_starter_file_, &psi_o );
					break;

				default:
					throw std::runtime_error( "Unrecognized starter type!" );
			}

			if (write_starter_) {
				std::cout << "Outputting starter..." << std::endl;
				outputVec( psi_o, z, NZ,
					tag_filename(NCPAPROP_EPADE_PE_FILENAME_STARTER));
			}

			// get initial coefficients
			std::vector< PetscScalar > P, Q;
			std::vector< PetscScalar > taylor =
				this->taylor_exp_id_sqrt_1pQ_m1( 2*npade_, k0*dr );
			this->calculate_pade_coefficients( &taylor, npade_, npade_+1,
				&P, &Q );
			this->generate_polymatrices( qpowers_starter, npade_, NZ, P, Q,
				&B, &C );

			std::cout << "Marching out field..." << std::endl;
			ierr = VecDuplicate( psi_o, &Bpsi_o );CHKERRQ(ierr);
			contents = NCPA::zeros<PetscScalar>( NZ );

			ierr = KSPCreate( PETSC_COMM_SELF, &ksp );CHKERRQ(ierr);
			ierr = KSPSetOperators( ksp, C, C );CHKERRQ(ierr);
			ierr = KSPSetFromOptions( ksp );CHKERRQ(ierr);

			// start range loop
			size_t ir = 0;
			for (vec_it r_it = r_vector_.cbegin();
						r_it != r_vector_.cend();
						++r_it) {

				ir = std::distance( r_vector_.cbegin(), r_it );
				rr = *r_it;
				// check to see if atmosphere has changed
				if (((int)(atm_profile_2d_->get_profile_index( rr ))) != profile_index) {
					profile_index = atm_profile_2d_->get_profile_index( rr );
					this->calculate_atmosphere_parameters(
						z_vector_, rr, z_ground, false, k0, c0, c, a_t, k, n );
					delete_matrix_polynomial( npade_+1, &qpowers );
					this->build_operator_matrix_without_topography(
						z_vector_, k0, h2, ground_impedence_factor, n,
						npade_+1, 0, &q );
					this->create_matrix_polynomial( npade_+1, &q, &qpowers );
					ierr = MatDestroy( &q );CHKERRQ(ierr);

					taylor.clear();
					taylor = taylor_exp_id_sqrt_1pQ_m1( 2*npade_, k0*dr );
					calculate_pade_coefficients( &taylor, npade_, npade_+1,
						&P, &Q );
					ierr = MatZeroEntries( B );CHKERRQ(ierr);
					ierr = MatZeroEntries( C );CHKERRQ(ierr);
					this->generate_polymatrices( qpowers_starter, npade_, NZ, P, Q,
						&B, &C );
					std::cout << "Switching to atmosphere index " << profile_index
						<< " at range = " << rr/1000.0 << " km" << std::endl;
				}

				// get values for current step
				ierr = VecGetValues( psi_o, NZ, indices, contents );CHKERRQ(ierr);

				// turbulence?
				if (use_turbulence_) {
					if (ir == 0) {
						// calculate first step
						this->calculate_turbulence( rr, k0, 0, mu_r );
					} else {
						std::memcpy( mu_r, mu_rpdr, NZ*sizeof(double) );
					}
					this->calculate_turbulence( rr + dr, k0, 0, mu_rpdr );

					// apply the turbulent fluctuations.  Do this inside
					// the if() because we need to keep these modifications
					// to psi_o, as opposed to the scaling by the Hankel
					// function below
					for (i = 0; i < NZ; i++) {
						contents[ i ] *= std::exp( I * k0 * dr * 0.5 *
							(mu_r[ i ] + mu_rpdr[ i ]) );
					}

					// store the modified field
					ierr = VecSetValues( psi_o, NZ, indices, contents,
						INSERT_VALUES );CHKERRQ(ierr);
					ierr = VecAssemblyBegin( psi_o );CHKERRQ(ierr);
					ierr = VecAssemblyEnd( psi_o );CHKERRQ(ierr);
				}

				hank = sqrt( 2.0 / ( PI * k0 * rr ) ) * exp( I * ( k0 * rr - PI/4.0 ) );
				for (i = 0; i < NZ; i++) {
					tloss_[ i ][ ir ] = contents[ i ] * hank;
				}
				zgi_r_vector_.push_back(zri);

				if ( fmod( rr, 1.0e5 ) < dr) {
					std::cout << " -> Range " << rr/1000.0 << " km" << std::endl;
				}

				ierr = MatMult( B, psi_o, Bpsi_o );CHKERRQ(ierr);
				ierr = KSPSetOperators( ksp, C, C );CHKERRQ(ierr);  // may not be necessary
				ierr = KSPSolve( ksp, Bpsi_o, psi_o );CHKERRQ(ierr);
			} // loop over r
			std::cout << "Stopped at range " << r_vector_.back()/1000.0
					  << " km" << std::endl;

			if (this->getMultiprop()) {
				std::cout << "Writing 1-D output to "
						  << tag_filename(NCPAPROP_EPADE_PE_FILENAME_MULTIPROP)
						  << std::endl;
				output1DTL(
					tag_filename(NCPAPROP_EPADE_PE_FILENAME_MULTIPROP),
					true );
			} else {
				std::cout << "Writing 1-D output to "
					<< tag_filename(NCPAPROP_EPADE_PE_FILENAME_1D)
					<< std::endl;
				output1DTL( tag_filename(NCPAPROP_EPADE_PE_FILENAME_1D),
					this->getBroadband() );
				if (this->getWrite2DTransmissionLoss()) {
					std::cout << "Writing 2-D output to "
						<< tag_filename(NCPAPROP_EPADE_PE_FILENAME_2D)
						<< std::endl;
					output2DTL( tag_filename(NCPAPROP_EPADE_PE_FILENAME_2D) );
				}
			}

			if (this->getBroadband()) {
				this->write_broadband_results(
					tag_filename(NCPAPROP_EPADE_PE_FILENAME_BROADBAND),
					NCPAPROP_EPADE_PE_BROADBAND_BINARY_PRECISION_FACTOR );
			}

			if (this->getWriteAtmosphere()) {
				std::cout << "Writing source atmosphere to "
						<< tag_filename(NCPAPROP_EPADE_PE_FILENAME_ATMOSPHERE)
						<< std::endl;
				std::vector<std::string> keylist;
				keylist.push_back( "U" );
				keylist.push_back( "V" );
				keylist.push_back( "T" );
				keylist.push_back( "RHO" );
				keylist.push_back( "P" );
				keylist.push_back( "_C0_" );
				keylist.push_back( "_CEFF_" );
				std::ofstream atmout(
					tag_filename( NCPAPROP_EPADE_PE_FILENAME_ATMOSPHERE ) );
				atm_profile_2d->print_atmosphere( keylist, 0.0, "Z", atmout );
				atmout.close();
			}

			std::cout << std::endl;

			// clean up
			if (this->getUseTurbulence()) {
				delete [] mu_r;
				delete [] mu_rpdr;
				this->cleanup_turbulence();
			}

			this->delete_matrix_polynomial( npade_+1, &qpowers );

			if (starter_type_ == NCPA::StarterType::SELF) {
				this->delete_matrix_polynomial( npade_+1, &qpowers_starter );
			}

			zgi_r_vector_.clear();
			NCPA::free_matrix<std::complex<double>>( tloss_, NZ, nr_ );
			// remove calculated effective sound speed.  If it's been
			// user-specified it'll still be there in "CEFF" to be copied
			// in again.
			atm_profile_2d_->remove_property("_CEFF_");

			ierr = MatDestroy( &B );       CHKERRQ(ierr);
			ierr = MatDestroy( &C );       CHKERRQ(ierr);
			ierr = VecDestroy( &psi_o );   CHKERRQ(ierr);
			ierr = VecDestroy( &Bpsi_o );  CHKERRQ(ierr);
			ierr = KSPDestroy( &ksp );     CHKERRQ(ierr);

			delete [] k;
			delete [] n;
			delete [] c;
			delete [] a_t;
			delete [] contents;
			delete [] indices;
			z_vector_.clear();
			z_abs_vector_.clear();
		} // loop over az

		r_vector_.clear();
		if (!this->getUserAttenuationUsed()) {
			atm_profile_2d_->remove_property( "_ALPHA_" );
		}

	} // loop over f

	return 1;
}

int NCPA::EPadeSolver::solve_with_topography() {

	// local variables, may move to global space if used elsewhere
	size_t i;
	std::complex<double> I( 0.0, 1.0 );
	PetscErrorCode ierr;
	PetscInt *indices;
	PetscScalar hank, *contents;
	Mat B, C;
	Mat *qpowers = PETSC_NULL, *qpowers_starter = PETSC_NULL;
	Vec psi_o, Bpsi_o;;
	KSP ksp;
	int profile_index, ground_index = 0;
	double z_max, z_ground, zs, zr, dz, *z, *z_abs, grid_tolerance,
		h, h2, dr, k0, c0, *c, *a_t, z_bottom, lambda0;
	size_t NZ;
	std::complex<double> ground_impedence_factor( 0.0, 0.0 ), *k, *n;

	// for turbulence, if needed
	double *mu_r, *mu_rpdr;
	std::vector<double> rand1, rand2;

	// info for z grid
	atm_profile_2d_->get_maximum_altitude_limits( minlimit, maxlimit );
	z_bottom = -NCPAPROP_EPADE_PE_BASEMENT_THICKNESS;    // make this eventually depend on frequency
	z_bottom -= std::fmod( z_bottom, dz );
	z_ground = atm_profile_2d->get_interpolated_ground_elevation( 0.0 );

	// get non-random turbulence if needed
	if (getUseTurbulence() && !getUseRandomTurbulence()) {
		std::cout << "Reading " << 2*nturbulence_ << " values from "
				  << turbulence_file_ << std::endl;
		std::ifstream rand_in( turbulence_file_ );
		rand1.reserve( nturbulence_ );
		rand2.reserve( nturbulence_ );
		if (!NCPA::read_values( rand_in, nturbulence_, rand1 )) {
			throw std::runtime_error( "Error reading from " + turbulence_file_ );
		}
		if (!NCPA::read_values( rand_in, nturbulence_, rand2 )) {
			throw std::runtime_error( "Error reading from " + turbulence_file_ );
		}
		rand_in.close();
	}

	for (vec_it freq_it = frequency_vector_.cbegin();
				freq_it != frequency_vector_.cend();
				++freq_it ) {

		freq_ = *freq_it;

		// calculate and store attenuation if not user-supplied
		if ((!lossless_) && (!user_attenuation_)) {
			atm_profile_2d_->calculate_attenuation( "_ALPHA_",
				"T", "P", "RHO", freq_ );
		}

		// calculate the r vector
		if (user_nr_ == 0) {
			dr = NCPAPROP_EPADE_PE_SOUNDSPEED_FOR_DR / freq_;
			nr_ = (int)std::ceil( r_max_ / dr );
		} else {
			nr_ = nr_user_;
			dr = r_max_ / nr_;
		}

		std::cout << "Setting dr to " << dr << " meters." << std::endl;

		r_vector_.clear();
		r_vector_.reserve( nr_ );

		for (i = 0; i < nr_; i++) {
			r_vector_.push_back( ((double)(i+1)) * dr );
		}

		for (vec_it az_it = azimuth_vector_.cbegin();
					az_it != azimuth_vector_.cend();
					++az_it ) {

			calc_az_ = *az_it;
			profile_index = -1;
			zgi_r_vector_.clear();
			zgi_r_vector_.reserve( nr_ );

			// calculate the effective sound speed for this azimuth
			// and store in the atmosphere object
			this->calculate_effective_sound_speed( atm_profile_2d_, calc_az_,
				"_CEFF_" );

			// calculate z vectors
			z_ground = atm_profile_2d_->get(0.0,"Z0");
			c0 = atm_profile_2d_->get(0.0,"_CEFF_",z_ground);
			if (user_dz_used_) {
				if (dz_.get() > (c0 / freq_ / 10.0)) {
					oss << "Altitude resolution is too coarse.  Must be <= "
						c0 / freq_ / 10.0 << "m";
					throw std::runtime_error( oss.str() );
				}
			} else {
				lambda0 = c0 / freq_;
				double tmpdz = lambda0 / 20.0;
				double nearestpow10 = std::pow( 10.0,
					std::floor( std::log10( tmpdz ) ) );
		  		double factor = std::floor( tmpdz / nearestpow10 );
		  		tmpdz = nearestpow10 * factor;
		  		std::cout << "Setting dz to " << tmpdz << " m" << std::endl;
		  		dz_.set(tmpdz,u_m);
		  	}
		  	NZ = ((int)std::floor((z_max - z_bottom) / dz)) + 1;
		  	z_vector_.clear();
		  	z_vector_.reserve( NZ );
		  	z_vector_abs_.clear();
		  	z_vector_abs_.reserve( NZ );
			indices = NCPA::index_vector<PetscInt>( NZ );
			for (i = 0; i < NZ; i++) {
				z_vector_.push_back( ((double)i) * dz + z_bottom );
				z_abs_vector_.push_back( z_vector_[ i ] );
			}
			double grid_tolerance =
				dz_.get() * NCPAPROP_EPADE_PE_GRID_COINCIDENCE_TOLERANCE_FACTOR;
			z_ground = check_ground_height_coincidence_with_grid(
				z_ground, grid_tolerance );
			zs = NCPA::max( z_source_.get(), z_ground );

			// define ground_index, which is J in @notes
			ground_index = (int)(NCPA::find_closest_index(
				z_vector_, z_ground ));
			if ( z_vector_[ ground_index ] < z_ground ) {
				ground_index++;
			}

			// adjust source height if it falls within 5% of a ground point
			int closest_source_grid_point =
				(int)(NCPA::find_closest_index( z_vector_, zs ));
			if (fabs(zs - z_vector_[ closest_source_grid_point ])
					< grid_tolerance) {
				zs = z_vector_[ closest_source_grid_point ] + grid_tolerance;
				std::cout << "Adjusting source height to " << zs
					<< " m to avoid grid point singularity" << std::endl;
			}

			// initialize other variables
			h = dz_.get();
			h2 = h*h;
			k0 = 0.0;
			c0 = 0.0;
			c = NCPA::zeros<double>( NZ );
			a_t = NCPA::zeros<double>( NZ );
			k = NCPA::zeros<std::complex<double>>( NZ );
			n = NCPA::zeros<std::complex<double>>( NZ );
			tl = NCPA::allocate_matrix<std::complex<double>>( NZ, nr_-1 );

			// calculate ground impedence (script A in notes in eq. 12)
			double rho0 = atm_profile_2d_->get( 0.0, "RHO", z_ground );
			double lambBC = atm_profile_2d_->get_first_derivative(
				0.0, "RHO", z_ground ) / (2.0 * rho0);

			if (user_ground_impedence_used_) {
				ground_impedence_factor = I * 2.0 * PI * freq_ * rho0
					/ user_ground_impedence_ + lambBC;
				std::cout << "Using user ground impedence of " << user_ground_impedence << std::endl;
			} else {
				ground_impedence_factor.real( lambBC );
				ground_impedence_factor.imag( 0.0 );
				std::cout << "Using default rigid ground with Lamb BC" << std::endl;
			}

			this->calculate_atmosphere_parameters( z_vector_, 0.0, z_ground,
				true, k0, c0, c, a_t, k, n );

			// calculate turbulence
			if (use_turbulence_) {
				mu_r = NCPA::zeros<double>( NZ );
				mu_rpdr = NCPA::zeros<double>( NZ );
				this->setup_turbulence(rand1, rand2);
			}

			// calculate starter field
			switch (starter_type_) {
				case NCPA::StarterType::SELF:

					// for now build the non-topographic starter
					// revisit when time and funding permit
					size_t NZ_starter = NZ - ground_index;
					double *c_starter, *a_starter,
						   k0_starter, c0_starter;
					std::complex<double> *k_starter, *n_starter;
					std::vector<double> z_starter;
					c_starter = NCPA::zeros<double>( NZ_starter );
					a_starter = NCPA::zeros<double>( NZ_starter );
					k_starter = NCPA::zeros<std::complex<double>>( NZ_starter );
					n_starter = NCPA::zeros<std::complex<double>>( NZ_starter );
					z_starter.reserve( NZ_starter );
					size_t ii;
					for (ii = 0; ii < NZ_starter; ii++) {
						z_starter.push_back( z_vector_[ ii + ground_index ] );
					}
					this->calculate_atmosphere_parameters(
						z_starter, 0.0, z_ground, false,
						k0_starter, c0_starter, c_starter, a_starter,
						k_starter, n_starter );

					Mat q_starter = PETSC_NULL;
					Mat *qpowers_starter = PETSC_NULL;
					this->build_operator_matrix_without_topography(
						z_starter, k0_starter, h2, ground_impedence_factor,
						n_starter, npade_+1, 0, &q_starter );
					this->create_matrix_polynomial( npade_+1, &q_starter,
						&qpowers_starter );
					this->get_starter_self( z_starter, 0, z_ground, zs,
						k0_starter, qpowers_starter, true, &psi_o );


					// now interpolate calculated starter to actual Z vector
					std::deque< double > z_spline, r_spline, i_spline, c_spline;
					PetscScalar *psi_orig = NCPA::zeros<PetscScalar>( NZ_starter );
					PetscInt *starter_indices = NCPA::index_vector<PetscInt>( NZ_starter );
					ierr = VecGetValues( psi_o, NZ_starter, starter_indices, psi_orig );CHKERRQ(ierr);
					for (ii = 0; ii < NZ_starter; ii++) {
						z_spline.push_back( z_starter[ ii ] );
						r_spline.push_back( psi_orig[ ii ].real() );
						i_spline.push_back( psi_orig[ ii ].imag() );
					}
					ierr = VecDestroy( &psi_o );
					interpolate_starter( z_spline, r_spline, i_spline,
						NZ_spline, z_spline, c_spline );
					deque2Vec( c_spline, *psi_o );
					// clean up temp variables
					z_starter.clear();
					delete [] k_starter;
					delete [] n_starter;
					delete [] c_starter;
					delete [] a_starter;
					delete [] starter_indices;
					delete [] psi_orig;
					ierr = MatDestroy( &q_starter );CHKERRQ(ierr);
					delete_matrix_polynomial( npade+1, &qpowers_starter );

					build_operator_matrix_with_topography(
						0.0, k, k0,
						h2, z_ground, ground_impedence_factor, n,
						ground_index, PETSC_NULL, &q, true );
					create_matrix_polynomial( npade_+1, &q, &qpowers );
					ierr = MatDestroy( &q );CHKERRQ(ierr);
					break;

				case NCPA::StarterType::GAUSSIAN:
					build_operator_matrix_with_topography(
						0.0, k, k0,
						h2, z_ground, ground_impedence_factor, n,
						ground_index, PETSC_NULL, &q, true );
					create_matrix_polynomial( npade_+1, &q, &qpowers );
					ierr = MatDestroy( &q );CHKERRQ(ierr);
					get_starter_gaussian( k0, ground_index, &psi_o );
					break;

				case NCPA::StarterType::USER:
					build_operator_matrix_with_topography(
						0.0, k, k0,
						h2, z_ground, ground_impedence_factor, n,
						ground_index, PETSC_NULL, &q, true );
					create_matrix_polynomial( npade_+1, &q, &qpowers );
					ierr = MatDestroy( &q );CHKERRQ(ierr);
					get_starter_user( user_starter_file_, &psi_o );
					break;

				default:
					throw std::runtime_error( "Unrecognized starter type!" );
			}

			if (write_starter_) {
				std::cout << "Outputting starter..." << std::endl;
				outputVec( psi_o, z, NZ,
					tag_filename(NCPAPROP_EPADE_PE_FILENAME_STARTER));
			}

			// get initial coefficients
			std::vector< PetscScalar > P, Q;
			std::vector< PetscScalar > taylor =
				this->taylor_exp_id_sqrt_1pQ_m1( 2*npade_, k0*dr );
			this->calculate_pade_coefficients( &taylor, npade_, npade_+1,
				&P, &Q );
			this->generate_polymatrices( qpowers_starter, npade_, NZ, P, Q,
				&B, &C );

			std::cout << "Marching out field..." << std::endl;
			ierr = VecDuplicate( psi_o, &Bpsi_o );CHKERRQ(ierr);
			contents = NCPA::zeros<PetscScalar>( NZ );

			ierr = KSPCreate( PETSC_COMM_SELF, &ksp );CHKERRQ(ierr);
			ierr = KSPSetOperators( ksp, C, C );CHKERRQ(ierr);
			ierr = KSPSetFromOptions( ksp );CHKERRQ(ierr);

			// start range loop
			size_t ir = 0;
			for (vec_it r_it = r_vector_.cbegin();
						r_it != r_vector_.cend();
						++r_it) {

				ir = std::distance( r_vector_.cbegin(), r_it );
				rr = *r_it;
				z_ground = check_ground_height_coincidence_with_grid(
					atm_profile_2d->get_interpolated_ground_elevation( rr ),
					grid_tolerance );
				ground_index = (int)(NCPA::find_closest_index(
					z_vector_, z_ground ));
				if ( z_vector_[ ground_index ] < z_ground ) {
					ground_index++;
				}
				this->calculate_atmosphere_parameters( z_vector_, rr,
					z_ground, true, k0, c0, c, a_t, k, n );
				Mat last_q;
				ierr = MatConvert( qpowers[0], MATSAME, MAT_INITIAL_MATRIX,
					&last_q );CHKERRQ(ierr);
				delete_matrix_polynomial( npade_+1, &qpowers );

				build_operator_matrix_with_topography(
						rr, k, k0,
						h2, z_ground, ground_impedence_factor, n,
						ground_index, last_q, &q );
				create_matrix_polynomial( npade_+1, &q, &qpowers );
				ierr = MatDestroy( &last_q );CHKERRQ(ierr);
				ierr = MatDestroy( &q );CHKERRQ(ierr);

				taylor = taylor_exp_id_sqrt_1pQ_m1( 2*npade_, k0*dr );
				calculate_pade_coefficients( &taylor, npade_, npade_+1, &P, &Q );
				ierr = MatZeroEntries( B );CHKERRQ(ierr);
				ierr = MatZeroEntries( C );CHKERRQ(ierr);
				generate_polymatrices( qpowers, npade_, NZ, P, Q, &B, &C );

				// get values for current step
				ierr = VecGetValues( psi_o, NZ, indices, contents );CHKERRQ(ierr);

				// turbulence?
				if (use_turbulence_) {
					if (ir == 0) {
						// calculate first step
						this->calculate_turbulence( rr, k0, 0, mu_r );
					} else {
						std::memcpy( mu_r, mu_rpdr, NZ*sizeof(double) );
					}
					this->calculate_turbulence( rr + dr, k0, 0, mu_rpdr );

					// apply the turbulent fluctuations.  Do this inside
					// the if() because we need to keep these modifications
					// to psi_o, as opposed to the scaling by the Hankel
					// function below
					for (i = 0; i < NZ; i++) {
						contents[ i ] *= std::exp( I * k0 * dr * 0.5 *
							(mu_r[ i ] + mu_rpdr[ i ]) );
					}

					// store the modified field
					ierr = VecSetValues( psi_o, NZ, indices, contents,
						INSERT_VALUES );CHKERRQ(ierr);
					ierr = VecAssemblyBegin( psi_o );CHKERRQ(ierr);
					ierr = VecAssemblyEnd( psi_o );CHKERRQ(ierr);
				}

				hank = sqrt( 2.0 / ( PI * k0 * rr ) ) * exp( I * ( k0 * rr - PI/4.0 ) );
				for (i = 0; i < NZ; i++) {
					tloss_[ i ][ ir ] = contents[ i ] * hank;
				}
				zgi_r_vector_.push_back( ground_index );

				if ( fmod( rr, 1.0e5 ) < dr) {
					std::cout << " -> Range " << rr/1000.0 << " km" << std::endl;
				}

				ierr = MatMult( B, psi_o, Bpsi_o );CHKERRQ(ierr);
				ierr = KSPSetOperators( ksp, C, C );CHKERRQ(ierr);  // may not be necessary
				ierr = KSPSolve( ksp, Bpsi_o, psi_o );CHKERRQ(ierr);

			} // loop over r
			std::cout << "Stopped at range " << r_vector_.back()/1000.0
					  << " km" << std::endl;

			if (this->getMultiprop()) {
				std::cout << "Writing 1-D output to "
						  << tag_filename(NCPAPROP_EPADE_PE_FILENAME_MULTIPROP)
						  << std::endl;
				output1DTL(
					tag_filename(NCPAPROP_EPADE_PE_FILENAME_MULTIPROP),
					true );
			} else {
				std::cout << "Writing 1-D output to "
					<< tag_filename(NCPAPROP_EPADE_PE_FILENAME_1D)
					<< std::endl;
				output1DTL( tag_filename(NCPAPROP_EPADE_PE_FILENAME_1D),
					this->getBroadband() );
				if (this->getWrite2DTransmissionLoss()) {
					std::cout << "Writing 2-D output to "
						<< tag_filename(NCPAPROP_EPADE_PE_FILENAME_2D)
						<< std::endl;
					output2DTL( tag_filename(NCPAPROP_EPADE_PE_FILENAME_2D) );
				}
			}

			if (this->getBroadband()) {
				this->write_broadband_results(
					tag_filename(NCPAPROP_EPADE_PE_FILENAME_BROADBAND),
					NCPAPROP_EPADE_PE_BROADBAND_BINARY_PRECISION_FACTOR );
			}

			if (this->getWriteAtmosphere()) {
				std::cout << "Writing source atmosphere to "
						<< tag_filename(NCPAPROP_EPADE_PE_FILENAME_ATMOSPHERE)
						<< std::endl;
				std::vector<std::string> keylist;
				keylist.push_back( "U" );
				keylist.push_back( "V" );
				keylist.push_back( "T" );
				keylist.push_back( "RHO" );
				keylist.push_back( "P" );
				keylist.push_back( "_C0_" );
				keylist.push_back( "_CEFF_" );
				std::ofstream atmout(
					tag_filename( NCPAPROP_EPADE_PE_FILENAME_ATMOSPHERE ) );
				atm_profile_2d->print_atmosphere( keylist, 0.0, "Z", atmout );
				atmout.close();
			}

			std::cout << std::endl;

			// clean up
			if (this->getUseTurbulence()) {
				delete [] mu_r;
				delete [] mu_rpdr;
				this->cleanup_turbulence();
			}

			this->delete_matrix_polynomial( npade_+1, &qpowers );

			if (starter_type_ == NCPA::StarterType::SELF) {
				this->delete_matrix_polynomial( npade_+1, &qpowers_starter );
			}
			if (!this->getUserAttenuationUsed()) {
				atm_profile_2d_->remove_property( "_ALPHA_" );
			}
			zgi_r_vector_.clear();
			NCPA::free_matrix<std::complex<double>>( tloss_, NZ, nr_ );
			// remove calculated effective sound speed.  If it's been
			// user-specified it'll still be there in "CEFF" to be copied
			// in again.
			atm_profile_2d_->remove_property("_CEFF_");

			ierr = MatDestroy( &B );       CHKERRQ(ierr);
			ierr = MatDestroy( &C );       CHKERRQ(ierr);
			ierr = VecDestroy( &psi_o );   CHKERRQ(ierr);
			ierr = VecDestroy( &Bpsi_o );  CHKERRQ(ierr);
			ierr = KSPDestroy( &ksp );     CHKERRQ(ierr);

			delete [] k;
			delete [] n;
			delete [] c;
			delete [] a_t;
			delete [] contents;
			delete [] indices;
			z_vector_.clear();
			z_abs_vector_.clear();

		} // loop over az

		r_vector_.clear();

	} // loop over f

	return 1;
}

// @todo update header
int NCPA::EPadeSolver::build_operator_matrix_with_topography(
	double r, std::complex<double> *k, double k0, double h2,
	double z_s, std::complex<double> impedence_factor,
	std::complex<double> *n, int boundary_index, const Mat &last_q,
	Mat *q, bool starter ) {

	//Mat q;
	PetscInt Istart, Iend, *col, *indices;
	PetscInt *nonzeros;
	PetscBool FirstBlock = PETSC_FALSE, LastBlock = PETSC_FALSE;
	PetscErrorCode ierr;
	PetscScalar value[3], *rowDiff;
	PetscInt i, j;
	size_t NZvec = z_vector_.size();

	// Calculate parameters
	double h = std::sqrt( h2 );
	double J_s = (z_s - z_vector_[0]) / h;
	int Ji = (int)(NCPA::find_closest_index( z_vector_, z_s ));  // first index above ground
	if ( z_vector_[ Ji ] < z_s ) {
		Ji++;
	}
	double dJ = (double)Ji;
	//double dJ = zvec[ Ji ] / h;

	// number of nonzero values
	nonzeros = NCPA::single_valued_vector<PetscInt>( NZvec, 3 );
	indices = NCPA::index_vector<PetscInt>( NZvec );
	col = NCPA::zeros<PetscInt>( NZvec );
	nonzeros[ 0 ] = 2;
	nonzeros[ NZvec-1 ] = 2;


	// calculate intermediate variables as shown in notes
	double rho_a, rho_b, Gamma;
	double Anom, Bnom, denom;
	double s_A, s_B, a, b, c, alpha, beta, gamma;

	rho_a = atm_profile_2d_->get( r, "RHO", z_s );
	Gamma = 0.5 * atm_profile_2d_->get_first_derivative( r, "RHO", z_s ) / rho_a;
	rho_b = RHO_B;
	Anom = (1.0 / rho_a) * (1.0 / (dJ - J_s));
	if (starter) {
		Bnom = 0;    // for starter, rho_b = inf
	} else {
		Bnom = (1.0 / rho_b) * (1.0 / (J_s - dJ + 1.0));
	}
	denom = Anom + Bnom - (h * Gamma);
	s_A = Anom / denom;
	s_B = Bnom / denom;
	a   = s_B / (dJ - J_s);
	b   = (s_A - 2.0) / (dJ - J_s);
	c   = 1.0 / (dJ - J_s);
	alpha = 1.0 / (J_s - dJ + 1.0);
	beta  = (s_B - 2.0) / (J_s - dJ + 1.0);
	gamma = s_A / (J_s - dJ + 1.0);

	// Calculate matrix ratio representation of sqrt(1+Q)
	rowDiff = new PetscScalar[ NZvec ];
	if (last_q != PETSC_NULL) {
		PetscScalar I( 0.0, 1.0 ), *rowAbove, *rowBelow;
		PetscScalar M = I * k0
			* atm_profile_2d_->get_interpolated_ground_elevation_first_derivative( r )
			* h / denom;
		Vec vecAbove, vecBelow;
		PetscInt num_nonzeros;
		approximate_sqrt_1pQ( NZvec, &last_q, Ji, &vecBelow, &vecAbove,
			&num_nonzeros );
		ierr = VecScale( vecBelow, M );CHKERRQ(ierr);
		ierr = VecScale( vecAbove, M );CHKERRQ(ierr);

		// get the Ji'th and (Ji-1)'th rows of the M matrix
		rowBelow = NCPA::zeros<PetscScalar>( NZvec );
		ierr = VecGetValues( vecBelow, NZvec, indices, rowBelow );CHKERRQ(ierr);
		nonzeros[ Ji-1 ] = num_nonzeros;

		rowAbove = NCPA::zeros<PetscScalar>( NZvec );
		ierr = VecGetValues( vecAbove, NZvec, indices, rowAbove );CHKERRQ(ierr);
		nonzeros[ Ji ] = num_nonzeros;

		for (i = 0; i < NZvec; i++) {
			rowDiff[ i ] = rowAbove[ i ] - rowBelow[ i ];
		}

		delete [] rowAbove;
		delete [] rowBelow;
		ierr = VecDestroy( &vecAbove );CHKERRQ(ierr);
		ierr = VecDestroy( &vecBelow );CHKERRQ(ierr);
	}

	// Set up matrices
	ierr = MatCreateSeqAIJ( PETSC_COMM_SELF, NZvec, NZvec, 0, nonzeros, q );CHKERRQ(ierr);
	ierr = MatSetFromOptions( *q );CHKERRQ(ierr);


	// populate
	double k02 = k0*k0;

	// If this process is being split over processors, we need to check to see
	// if this particular instance contains the first or last rows, because those
	// get filled differently
	ierr = MatGetOwnershipRange(*q,&Istart,&Iend);CHKERRQ(ierr);

	// Does this instance contain the first row?
	if (Istart == 0) {
		FirstBlock=PETSC_TRUE;
	}

	// Does this instance contain the last row?
    if (Iend==(PetscInt)NZ) {
    	LastBlock=PETSC_TRUE;
    }

    // iterate over block.  If this instance contains the first row, leave that one
    // for later, same for if this instance contains the last row.
    PetscScalar *Drow = NCPA::zeros<PetscScalar>( NZvec );
    for( i=(FirstBlock? Istart+1: Istart); i<(LastBlock? Iend-1: Iend); i++ ) {

		// set column numbers.  Since the matrix Q is tridiagonal (because input
		// matrix D is tridiagonal and K is diagonal), column indices are
		// i-1, i, i+1
    	col[ 0 ] = i-1;
    	col[ 1 ] = i;
    	col[ 2 ] = i+1;

    	// Set values.  This will be the same unless we're at the indices immediately
    	// below or above the ground surface
    	if (i == (Ji-1)) {

    		if (last_q != PETSC_NULL) {
	    		// this is the alpha, beta, gamma row
	    		std::memcpy( col, indices, NZvec*sizeof(PetscInt) );
	    		for (j = 0; j < NZvec; j++) {
	    			Drow[ j ] = -rowDiff[ j ] / ( h2 * (J_s - dJ + 1.0));
	    		}

	    		Drow[ Ji-2 ] += alpha;
	    		Drow[ Ji-1 ] += beta;
	    		Drow[  Ji  ] += gamma;
	    	} else {   // M == 0
	    		Drow[0] = alpha;
	    		Drow[1] = beta;
	    		Drow[2] = gamma;
	    	}

    	} else if (i == Ji) {
    		// this is the a, b, c row
    		if (last_q != PETSC_NULL) {
	    		std::memcpy( col, indices, NZvec*sizeof(PetscInt) );
	    		for (j = 0; j < NZvec; j++) {
	    			Drow[ j ] = -rowDiff[ j ] / ( h2 * (dJ - J_s));
	    		}

	    		Drow[ Ji-1 ] += a;
	    		Drow[  Ji  ] += b;
	    		Drow[ Ji+1 ] += c;
	    	} else {
	    		Drow[0] = a;
	    		Drow[1] = b;
	    		Drow[2] = c;
	    	}
    	} else {
    		Drow[0] = 1.0;
    		Drow[1] = -2.0;
    		Drow[2] = 1.0;
    	}

    	for (j = 0; j < nonzeros[ i ]; j++) {
    		if (col[j] == i) {
    			Drow[ j ] = ( (Drow[ j ] / h2) + k[ i ]*k[ i ] - k02 ) / k02;
    		} else {
    			Drow[ j ] /= (h2 * k02);
    		}
    	}
    	ierr = MatSetValues(*q,1,&i,nonzeros[ i ],col,Drow,INSERT_VALUES);CHKERRQ(ierr);
    }
    if (LastBlock) {
		    i=NZ-1; col[0]=NZ-2; col[1]=NZ-1;
		    value[ 0 ] = 1.0 / h2 / k02;
		    //value[ 1 ] = -2.0/h2/k02 + (n[i]*n[i] - 1);
		    value[ 1 ] = ( (-2.0 / h2) + k[ i ]*k[ i ] - k02 ) / k02;
		    ierr = MatSetValues(*q,1,&i,2,col,value,INSERT_VALUES);CHKERRQ(ierr);
    }
    if (FirstBlock) {
		    i=0; col[0]=0; col[1]=1;
		    if (i == (Ji-1))  {
		    	if (last_q != PETSC_NULL) {
			    	std::memcpy( col, indices, NZvec*sizeof(PetscInt) );
			    	for (j = 0; j < NZvec; j++) {
		    			Drow[ j ] = -rowDiff[ j ] / ( h2 * (J_s - dJ + 1.0));
		    		}
		    		// std::memcpy( Drow, rowBelow, NZvec*sizeof(PetscScalar) );

		    		Drow[ 0 ] += beta;
		    		Drow[ 1 ] += gamma;
		    	} else {
		    		Drow[ 0 ] = beta;
		    		Drow[ 1 ] = gamma;
		    	}
    		} else if (i == Ji) {
    			if (last_q != PETSC_NULL) {
	    			std::memcpy( col, indices, NZvec*sizeof(PetscInt) );
	    			for (j = 0; j < NZvec; j++) {
		    			Drow[ j ] = -rowDiff[ j ] / ( h2 * (dJ - J_s));
		    		}
		    		// std::memcpy( Drow, rowBelow, NZvec*sizeof(PetscScalar) );

		    		Drow[ 0 ] += b;
		    		Drow[ 1 ] += c;
		    	} else {
		    		Drow[ 0 ] = b;
		    		Drow[ 1 ] = c;
		    	}
    		} else {
    			Drow[0] = -2.0;
	    		Drow[1] = 1.0;
    		}
    		for (j = 0; j < nonzeros[ i ]; j++) {
	    		if (col[j] == i) {
	    			Drow[ j ] = ( (Drow[ j ] / h2) + k[ i ]*k[ i ] - k02 ) / k02;
	    		} else {
	    			Drow[ j ] /= (h2 * k02);
	    		}
	    	}

    		ierr = MatSetValues(*q,1,&i,nonzeros[i],col,Drow,INSERT_VALUES);CHKERRQ(ierr);
    }
    ierr = MatAssemblyBegin(*q,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
    ierr = MatAssemblyEnd(*q,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);

    delete [] nonzeros;
    delete [] indices;
    delete [] col;
    delete [] Drow;
    delete [] rowDiff;
	return 1;
}


int NCPA::EPadeSolver::approximate_sqrt_1pQ( int NZvec, const Mat *Q,
	PetscInt Ji, Vec *vecBelow, Vec *vecAbove, PetscInt *nonzeros ) {

	PetscErrorCode ierr;
	/* For order (1,0) */

	PetscInt nvals;
	const PetscInt *indices;
	Mat halfQ;
	const PetscScalar *values;
	const PetscScalar diag = 1;
	const PetscInt diagIndBelow = Ji-1;
	const PetscInt diagIndAbove = Ji;

	ierr = VecCreate( PETSC_COMM_SELF, vecBelow );CHKERRQ(ierr);
	ierr = VecSetType( *vecBelow, VECSEQ );CHKERRQ(ierr);
	ierr = VecSetFromOptions( *vecBelow );CHKERRQ(ierr);
	ierr = VecSetSizes( *vecBelow, PETSC_DECIDE, NZvec );CHKERRQ(ierr);
	ierr = VecSet( *vecBelow, 0 );CHKERRQ(ierr);
	ierr = VecCreate( PETSC_COMM_SELF, vecAbove );CHKERRQ(ierr);
	ierr = VecSetType( *vecAbove, VECSEQ );CHKERRQ(ierr);
	ierr = VecSetFromOptions( *vecAbove );CHKERRQ(ierr);
	ierr = VecSetSizes( *vecAbove, PETSC_DECIDE, NZvec );CHKERRQ(ierr);
	ierr = VecSet( *vecAbove, 0 );CHKERRQ(ierr);

	ierr = MatDuplicate( *Q, MAT_COPY_VALUES, &halfQ );CHKERRQ(ierr);
	ierr = MatScale( halfQ, 0.5 );
	ierr = MatGetRow( halfQ, Ji-1, &nvals, &indices, &values );CHKERRQ(ierr);
	ierr = VecSetValues( *vecBelow, nvals, indices, values, INSERT_VALUES );CHKERRQ(ierr);
	ierr = VecSetValues( *vecBelow, 1, &diagIndBelow, &diag, ADD_VALUES );CHKERRQ(ierr);
	*nonzeros = nvals;
	ierr = MatRestoreRow( halfQ, Ji-1, &nvals, &indices, &values );CHKERRQ(ierr);

	ierr = MatGetRow( halfQ, Ji, &nvals, &indices, &values );CHKERRQ(ierr);
	ierr = VecSetValues( *vecAbove, nvals, indices, values, INSERT_VALUES );CHKERRQ(ierr);
	ierr = VecSetValues( *vecAbove, 1, &diagIndAbove, &diag, ADD_VALUES );CHKERRQ(ierr);
	*nonzeros = NCPA::max( nvals, *nonzeros );
	ierr = MatRestoreRow( halfQ, Ji, &nvals, &indices, &values );CHKERRQ(ierr);

	ierr = VecAssemblyBegin( *vecBelow );CHKERRQ(ierr);
	ierr = VecAssemblyEnd( *vecBelow );CHKERRQ(ierr);
	ierr = VecAssemblyBegin( *vecAbove );CHKERRQ(ierr);
	ierr = VecAssemblyEnd( *vecAbove );CHKERRQ(ierr);

	ierr = MatDestroy( &halfQ );CHKERRQ(ierr);
	*nonzeros = NZvec / 10;
	return 1;
}



// @todo update header
double NCPA::EPadeSolver::check_ground_height_coincidence_with_grid(
	double z_ground, double tolerance ) {

	int closest_source_grid_point = (int)(NCPA::find_closest_index(
		z_vector_, z_ground ));
	if (std::fabs(z_ground - z_vector_[ closest_source_grid_point ]) < tolerance) {
		if (z_ground <= z_vector_[ closest_source_grid_point ]) {
			// ground is below grid point, move further down
			return z_vector_[ closest_source_grid_point ] - tolerance;
		} else {
			// ground is above grid point, move further up
			return z_vector_[ closest_source_grid_point ] + tolerance;
		}
	} else {
		return z_ground;
	}
}


void NCPA::EPadeSolver::output2DTL( std::string filename ) {
	std::ofstream out_2d( filename,
		std::ofstream::out | std::ofstream::trunc );
	int zplot_int = 10;
	for (size_t i = 0; i < (nr_-1); i++) {
		for (size_t j = 0; j < z_vector_.size(); j += zplot_int) {
			out_2d << r_vector_[ i ]/1000.0 << " "
				   << z_vector_[ j ]/1000.0 << " "
				   << tloss_[ j ][ i ].real() << " "
				   << tloss_[ j ][ i ].imag() << std::endl;
		}
		out_2d << std::endl;
	}
	out_2d.close();
}

void NCPA::EPadeSolver::output1DTL( std::string filename, bool append ) {
	std::ofstream out_1d;
	if (append) {
		out_1d.open( filename, std::ofstream::out | std::ofstream::app );
		out_1d << std::endl;
	} else {
		out_1d.open( filename, std::ofstream::out | std::ofstream::trunc );
	}

	// we'll use index instead of iterator because there's three variables
	for (size_t i = 0; i < (nr_-1); i++) {
		out_1d << r_vector_[ i ]/1000.0 << " " << calc_az_ << " "
			   << tloss_[ zgi_r_vector_[ i ] ][ i ].real() << " "
			   << tloss_[ zgi_r_vector_[ i ] ][ i ].imag() << std::endl;
	}
	out_1d.close();
}


// @todo update header
int NCPA::EPadeSolver::get_starter_user( std::string filename, Vec *psi ) {
	std::ifstream in( filename );
	std::string line;
	std::vector< std::string > filelines, fields;
	std::deque< double > z_file, r_file, i_file, c_file;
	size_t nlines, i;
	std::ostringstream oss;
	PetscErrorCode ierr;
	PetscScalar tempval;
	PetscInt ii;

	size_t NZ = z_vector_.size();
	std::getline( in, line );

	while ( in.good() ) {
		// lines will either be comments (# ), field descriptions (#% ), or
		// field contents
		line = NCPA::deblank( line );
		if (line[ 0 ] != '#') {
			filelines.push_back( line );
		}

		std::getline( in, line );
	}
	in.close();

	nlines = filelines.size();
	double this_z, this_r, this_i;

	for (i = 0; i < nlines; i++) {
		fields = NCPA::split( NCPA::deblank( filelines[ i ] ), " ," );
		if (fields.size() != 3) {
			oss << "EPadeSolver - Error parsing starter line:" << std::endl << line << std::endl
				<< "Must be formatted as:" << std::endl
				<< "altitude  realpart imagpart" << std::endl;
			throw std::invalid_argument( oss.str() );
		}

		try {
			this_z = std::stod( fields[ 0 ] );
			this_r = std::stod( fields[ 1 ] );
			this_i = std::stod( fields[ 2 ] );
		} catch ( std::invalid_argument &e ) {
			oss << "EPadeSolver - Error parsing starter line:" << std::endl << line << std::endl
				<< "All fields must be numeric" << std::endl;
			throw std::invalid_argument( oss.str() );
		}
		z_file.push_back( this_z * 1000.0 );
		r_file.push_back( this_r );
		i_file.push_back( this_i );
	}

	interpolate_complex_deque( z_file, r_file, i_file, NZ, z, c_file );
	deque2Vec( c_file, psi );

	return 1;
}

int deque2Vec( std::deque<double> c, Vec *psi ) {
	size_t NZ = c.size();
	// convert deque to Vec
	ierr = VecCreate( PETSC_COMM_SELF, psi );CHKERRQ(ierr);
	ierr = VecSetSizes( *psi, PETSC_DECIDE, NZ );CHKERRQ(ierr);
	ierr = VecSetFromOptions( *psi );CHKERRQ(ierr);
	ierr = VecSet( *psi, 0.0 );
	for (PetscInt ii = 0; ii < (PetscInt)NZ; i++) {
		tempval = c[ i ];
		ierr = VecSetValues( *psi, 1, &ii, &tempval, INSERT_VALUES );CHKERRQ(ierr);
	}
	ierr = VecAssemblyBegin( *psi );CHKERRQ(ierr);
	ierr = VecAssemblyEnd( *psi );CHKERRQ(ierr);
}


// int NCPA::EPadeSolver::interpolate_starter(
// 			std::deque<double> &z_orig, std::deque<double> &r_orig,
// 			std::deque<double> &i_orig,
// 			size_t NZ_new, double *z_new, Vec *psi ) {
// @todo update header
// @todo make static?
void NCPA::EPadeSolver::interpolate_complex_deque(
			std::deque<double> &z_orig, std::deque<double> &r_orig,
			std::deque<double> &i_orig,
			size_t NZ_new, double *z_new,
			std::deque<std::complex<double>> &out ) {


	std::complex<double> J( 0.0, 1.0 ), tempval;
	gsl_interp_accel *accel_r_, *accel_i_;
	gsl_spline *spline_r_, *spline_i_;
	double *z_spline, *r_spline, *i_spline;
	size_t ii;

	double dz = z_orig[ 1 ] - z_orig[ 0 ];
	while (z_orig.front() > z_new[ 0 ]) {
		z_orig.push_front( z_orig[ 0 ] - dz );
		r_orig.push_front( 0.0 );
		i_orig.push_front( 0.0 );
	}
	while (z_orig.back() < z_new[ NZ_new-1 ]) {
		z_orig.push_back( z_orig.back() + dz );
		r_orig.push_back( 0.0 );
		i_orig.push_back( 0.0 );
	}

	z_spline = new double[ z_orig.size() ];
	r_spline = new double[ z_orig.size() ];
	i_spline = new double[ z_orig.size() ];
	for (ii = 0; ii < z_orig.size(); ii++) {
		z_spline[ ii ] = z_orig[ ii ];
		r_spline[ ii ] = r_orig[ ii ];
		i_spline[ ii ] = i_orig[ ii ];
	}

	accel_r_ = gsl_interp_accel_alloc();
#if GSL_MAJOR_VERSION > 1
	spline_r_ = gsl_spline_alloc( gsl_interp_steffen, z_orig.size() );
#else
	spline_r_ = gsl_spline_alloc( gsl_interp_cspline, z_orig.size() );
#endif
	gsl_spline_init( spline_r_, z_spline, r_spline, z_orig.size() );
	accel_i_ = gsl_interp_accel_alloc();
#if GSL_MAJOR_VERSION > 1
	spline_i_ = gsl_spline_alloc( gsl_interp_steffen, z_orig.size() );
#else
	spline_i_ = gsl_spline_alloc( gsl_interp_cspline, z_orig.size() );
#endif
	gsl_spline_init( spline_i_, z_spline, i_spline, z_orig.size() );

	out.clear();
	out.reserve( NZ_new );
	for (ii = 0; ii < NZ_new; ii++) {
		tempval.real( gsl_spline_eval( spline_r_, z_new[ ii ], accel_r_ ) );
		tempval.imag( gsl_spline_eval( spline_i_, z_new[ ii ], accel_i_ ) );
		out.push_back( tempval );
	}
	gsl_spline_free( spline_r_ );
	gsl_spline_free( spline_i_ );
	gsl_interp_accel_free( accel_r_ );
	gsl_interp_accel_free( accel_i_ );

	delete [] z_spline;
	delete [] r_spline;
	delete [] i_spline;
}




// @todo update header
int NCPA::EPadeSolver::get_starter_gaussian( double k0, int ground_index,
	Vec *psi ) {

	double fac = 2.0;
	PetscScalar tempval;
	PetscErrorCode ierr;
	PetscInt NZ = z_vector_.size();

	ierr = VecCreate( PETSC_COMM_SELF, psi );CHKERRQ(ierr);
	ierr = VecSetSizes( *psi, PETSC_DECIDE, NZ );CHKERRQ(ierr);
	ierr = VecSetFromOptions( *psi ); CHKERRQ(ierr);
	ierr = VecSet( *psi, 0.0 );

	for (PetscInt i = 0; i < NZ; i++) {

		tempval = -( k0*k0/fac/fac )
			* (z_vector_[i] - z_source_.get() )
			* (z_vector_[i] - z_source_.get() );
		tempval = sqrt( k0/fac ) * exp( tempval );
		ierr = VecSetValues( *psi, 1, &i, &tempval, INSERT_VALUES );CHKERRQ(ierr);
	}
	ierr = VecAssemblyBegin( *psi );CHKERRQ(ierr);
	ierr = VecAssemblyEnd( *psi );CHKERRQ(ierr);
	return 1;
}

// int NCPA::EPadeSolver::get_starter_self(
// 	size_t NZ, double *z, double zs, int nzground,
// 	double k0, Mat *qpowers, size_t npade, bool absolute, Vec *psi ) {
// @todo update header
int NCPA::EPadeSolver::get_starter_self( std::vector<double> &z,
	int nzground, double z_ground, double z_source, double k0,
	Mat *qpowers, bool absolute, Vec *psi ) {

	Vec rhs, ksi, Bksi, tempvec;
	Mat B, C;
	KSP ksp2;
	PetscScalar I( 0.0, 1.0 ), tempsc, zeroval = 0.0;
	PetscErrorCode ierr;

	size_t NZ = z.size();

	// create rhs vector
	ierr = VecCreate( PETSC_COMM_SELF, &rhs );CHKERRQ(ierr);
	ierr = VecSetSizes( rhs, PETSC_DECIDE, NZ );CHKERRQ(ierr);
	ierr = VecSetFromOptions( rhs );CHKERRQ(ierr);
	ierr = VecSet( rhs, 0.0 );CHKERRQ(ierr);

	// find closest index to zs. Make sure the picked point is above
	// the ground surface if we're working in absolute elevation.  If
	// we're in relative elevation, the ground is at 0 by definition
	size_t nzsrc = NCPA::find_closest_index<double>( z, z_source );
	if (absolute) {
		while (z[nzsrc] < z_ground) {
			nzsrc++;
		}
	}

	double h = z[1] - z[0];
	PetscScalar hinv = 1.0 / h;
	PetscInt ps_nzsrc = nzsrc;
	ierr = VecSetValues( rhs, 1, &ps_nzsrc, &hinv, INSERT_VALUES );CHKERRQ(ierr);

	// solve first part (Eq. 26)
	ierr = VecDuplicate( rhs, &ksi );CHKERRQ(ierr);
	ierr = VecCopy( rhs, ksi );CHKERRQ(ierr);

	// get starter
	std::cout << "Finding ePade starter coefficients..." << std::endl;
	double r_ref = 2.0 * PI / k0;
	std::vector< PetscScalar > P, Q;
	std::vector< PetscScalar > taylor1 =
		this->taylor_sqrt_1pQ_exp_id_sqrt_1pQ_m1( 2*npade_, k0*r_ref );
	this->calculate_pade_coefficients( &taylor1, npade_, npade_+1, &P, &Q );

	this->generate_polymatrices( qpowers, npade, NZ, P, Q, &B, &C );
	PetscScalar hank_inv = pow(
		sqrt( 2.0 / ( PI * k0 * r_ref ) ) * exp( I * (k0 * r_ref - PI/4.0 ) ),
		-1.0 );

	// Original Matlab: psi = AA * ( C \ (B * ksi) ) / hank
	// compute product of B and ksi
	ierr = VecDuplicate( ksi, &Bksi );
	ierr = VecDuplicate( ksi, &tempvec );
	ierr = VecDuplicate( ksi, psi );
	ierr = MatMult( B, ksi, Bksi );

	// solve for tempvec = C \ Bksi
	ierr = KSPCreate( PETSC_COMM_WORLD, &ksp2 );CHKERRQ(ierr);
	ierr = KSPSetOperators( ksp2, C, C );CHKERRQ(ierr);
	ierr = KSPSetFromOptions( ksp2 );CHKERRQ(ierr);
	ierr = KSPSolve( ksp2, Bksi, *psi );CHKERRQ(ierr);

	// multiply and scale
	ierr = VecScale( *psi, hank_inv );CHKERRQ(ierr);


	// clean up
	ierr = MatDestroy( &B );CHKERRQ(ierr);
	ierr = MatDestroy( &C );CHKERRQ(ierr);
	ierr = VecDestroy( &rhs );CHKERRQ(ierr);
	ierr = VecDestroy( &ksi );CHKERRQ(ierr);
	ierr = VecDestroy( &Bksi );CHKERRQ(ierr);
	ierr = VecDestroy( &tempvec );CHKERRQ(ierr);
	ierr = KSPDestroy( &ksp2 );CHKERRQ(ierr);

	return 1;
}

// @todo make static?
int NCPA::EPadeSolver::generate_polymatrices(
	Mat *qpowers, size_t npade, size_t NZ,
	std::vector< std::complex< double > > &P,
	std::vector< std::complex< double > > &Q,
	Mat *B, Mat *C ) {

	PetscErrorCode ierr;
	PetscInt Istart, Iend, i;
	PetscScalar value;

	ierr = MatCreateSeqAIJ( PETSC_COMM_SELF, NZ, NZ, 2*npade-1, NULL, B );CHKERRQ(ierr);
	ierr = MatSetFromOptions( *B );CHKERRQ(ierr);
	ierr = MatCreateSeqAIJ( PETSC_COMM_SELF, NZ, NZ, 2*npade+1, NULL, C );CHKERRQ(ierr);
	ierr = MatSetFromOptions( *C );CHKERRQ(ierr);

	ierr = MatGetOwnershipRange(*B,&Istart,&Iend);CHKERRQ(ierr);
	// by definition Q[0] is 1.  It so happens that P[0] is also 1, but this is not
	// guaranteed.
	// @todo generalize this fot the case where P[0] != 1
	value = 1.0;
	for (i = Istart; i < Iend; i++) {
		ierr = MatSetValues( *B, 1, &i, 1, &i, &value, INSERT_VALUES );CHKERRQ(ierr);
	}
	ierr = MatGetOwnershipRange( *C, &Istart, &Iend );CHKERRQ(ierr);
	for (i = Istart; i < Iend; i++) {
		ierr = MatSetValues( *C, 1, &i, 1, &i, &value, INSERT_VALUES );CHKERRQ(ierr);
	}

	ierr = MatAssemblyBegin(*B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
    ierr = MatAssemblyEnd(*B,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
    ierr = MatAssemblyBegin(*C,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
    ierr = MatAssemblyEnd(*C,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);

    for (i = 1; i < (PetscInt)(Q.size()); i++) {
		ierr = MatAXPY( *C, Q[ i ], qpowers[ i-1 ], DIFFERENT_NONZERO_PATTERN );CHKERRQ(ierr);
	}
	for (i = 1; i < (PetscInt)(P.size()); i++) {
		ierr = MatAXPY( *B, P[ i ], qpowers[ i-1 ], DIFFERENT_NONZERO_PATTERN );CHKERRQ(ierr);
	}
	return 1;
}

// calculate Pade coefficients based on Taylor series
// @todo make static member?
int NCPA::EPadeSolver::calculate_pade_coefficients(
	std::vector<PetscScalar> *c, int n_numerator, int n_denominator,
	std::vector<PetscScalar> *numerator_coefficients,
	std::vector<PetscScalar> *denominator_coefficients ) {

	// sanity checks
	if (n_denominator < n_numerator) {
		std::cerr << "Denominator count must be >= numerator count for Pade calculation" << std::endl;
		exit(0);
	}
	int n = n_numerator - 1;    // numerator order
	int m = n_denominator - 1;  // denominator order
	int N = n + m;
	int n_taylor = c->size();
	if (n_taylor < (N+1)) {
		std::cerr << "Count of Taylor series must be at least " << (N+1) << " for numerator count "
				  << n_numerator << " and denominator count " << n_denominator << std::endl;
		exit(0);
	}

	std::complex<double> j( 0.0, 1.0 );
	PetscErrorCode ierr;
	PetscInt Istart, Iend, ii, jj, *indices;
	PetscScalar tempsc, *contents;
	Mat A;
	Vec x, y;
	KSP ksp;

	// Create and populate matrix system
	ierr = MatCreateSeqAIJ( PETSC_COMM_SELF, N, N, n_denominator, NULL, &A );CHKERRQ(ierr);
	ierr = MatSetFromOptions( A );CHKERRQ(ierr);
	ierr = MatZeroEntries( A );CHKERRQ(ierr);
	ierr = MatGetOwnershipRange(A,&Istart,&Iend);CHKERRQ(ierr);
	tempsc = -1.0;
    for (ii = Istart; ii < min(n,Iend); ii++) {
    	ierr = MatSetValues(A,1,&ii,1,&ii,&tempsc,INSERT_VALUES);CHKERRQ(ierr);
    }
    for (ii = Istart; ii < Iend; ii++) {
    	for (jj = n; jj <= min(Iend-1,ii+n); jj++) {
    		tempsc = c->at( ii-jj+n );
    		ierr = MatSetValues(A,1,&ii,1,&jj,&tempsc,INSERT_VALUES);CHKERRQ(ierr);
    	}
    }


    ierr = MatAssemblyBegin(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
    ierr = MatAssemblyEnd(A,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);

    // setup right-side vector
	ierr = VecCreate( PETSC_COMM_SELF, &x );CHKERRQ(ierr);
	ierr = VecSetSizes( x, PETSC_DECIDE, N );CHKERRQ(ierr);
	ierr = VecSetFromOptions( x ); CHKERRQ(ierr);
	ierr = VecDuplicate( x, &y );CHKERRQ(ierr);

	indices = new PetscInt[ N ];
	for (ii = 0; ii < N; ii++) {
		tempsc = -c->at( ii+1 );
		ierr = VecSetValues( y, 1, &ii, &tempsc, INSERT_VALUES );CHKERRQ(ierr);
		indices[ ii ] = ii;
	}
	ierr = VecAssemblyBegin( y );CHKERRQ(ierr);
	ierr = VecAssemblyEnd( y );CHKERRQ(ierr);

	ierr = VecSet( x, 0.0 );CHKERRQ(ierr);

	// solve
	ierr = KSPCreate( PETSC_COMM_WORLD, &ksp );CHKERRQ(ierr);
	ierr = KSPSetOperators( ksp, A, A );CHKERRQ(ierr);
	ierr = KSPSetFromOptions( ksp );CHKERRQ(ierr);
	ierr = KSPSolve( ksp, y, x );CHKERRQ(ierr);

	// populate P and Q vectors. Q is denominator coefficients (b), P is numerator coefficients (a)
	contents = new PetscScalar[ N ];
	ierr = VecGetValues( x, N, indices, contents );

	numerator_coefficients->clear();
	numerator_coefficients->push_back( c->at(0) );
	for (ii = 0; ii < n; ii++) {
		numerator_coefficients->push_back( contents[ ii ] );
	}
	denominator_coefficients->clear();
	denominator_coefficients->push_back( 1.0 );
	for (ii = n; ii < N; ii++) {
		denominator_coefficients->push_back( contents[ ii ] );
	}
	delete [] contents;
	delete [] indices;

	// clean up memory
	ierr = KSPDestroy( &ksp );CHKERRQ(ierr);
	ierr = VecDestroy( &x );CHKERRQ(ierr);
	ierr = VecDestroy( &y );CHKERRQ(ierr);
	ierr = MatDestroy( &A );CHKERRQ(ierr);
	return 0;
}

// Uses the recurrence relation derived by Assink to modify the Taylor series for
// F=exp[ i*d*( sqrt(1+Q) - 1 ) ] to F=exp[ i*d*( sqrt(1+Q) - 1 ) ] / sqrt( 1+Q )
// @todo make static?
std::vector<PetscScalar> NCPA::EPadeSolver::taylor_sqrt_1pQ_exp_id_sqrt_1pQ_m1(
	int N, double delta ) {

	std::complex<double> j( 0.0, 1.0 );

	// first get the original series
	std::vector<PetscScalar> c = taylor_exp_id_sqrt_1pQ_m1( N, delta );

	// Now modify
	std::vector<PetscScalar> d( N, 1.0 );
	for (int m = 1; m < N; m++) {
		d[ m ] = (j*delta*c[m-1] - ( ((double)(1 + 2*(m-1))) * d[m-1])) / (2.0*m);
	}

	return d;
}

// Uses the recurrence relation in Roberts & Thompson (2013, eq. 16) to compute the
// Taylor series coefficients for F=exp[ i*d*( sqrt(1+Q) - 1 ) ] up to order N-1
// (i.e. the first N terms)
// @todo make static?
std::vector<PetscScalar> NCPA::EPadeSolver::taylor_exp_id_sqrt_1pQ_m1(
	int N, double delta ) {
	std::complex<double> j( 0.0, 1.0 );
	std::vector<PetscScalar> c( N, 1.0 );
	//std::memset( c, 0, N*sizeof(PetscScalar) );
	//c[ 0 ] = 1.0;
	c[ 1 ] = j * 0.5 * delta;
	for ( int idx= 2; idx < N; idx++) {
		double dm = (double)(idx - 1);
		c[ idx ] = -((2.0*dm - 1.0) / (2.0*dm + 2.0)) * c[idx-1]
				   - (delta*delta / (4.0*dm*(dm+1.0))) * c[idx-2];
	}

	return c;
}

// create a vector of powers of a given matrix
// @todo make static?
int NCPA::EPadeSolver::create_matrix_polynomial(
			size_t nterms, const Mat *Q, Mat **qpowers ) {

	PetscErrorCode ierr;
	PetscInt i;

	if ((*qpowers) != PETSC_NULL) {
		delete_matrix_polynomial( nterms, qpowers );
	}

	*qpowers = new Mat[ nterms ];
	ierr = MatConvert( *Q, MATSAME, MAT_INITIAL_MATRIX, *qpowers );CHKERRQ(ierr);
	for (i = 1; i < (PetscInt)nterms; i++) {
		ierr = MatCreate( PETSC_COMM_SELF, (*qpowers) + i );CHKERRQ(ierr);
		ierr = MatSetFromOptions( (*qpowers)[ i ] );CHKERRQ(ierr);
		ierr = MatMatMult( (*qpowers)[i-1], (*qpowers)[0], MAT_INITIAL_MATRIX, PETSC_DEFAULT,
			(*qpowers) + i );CHKERRQ(ierr);
	}

	return 1;
}

// clean up a vector of powers of a matrix
// @todo make static?
int NCPA::EPadeSolver::delete_matrix_polynomial(
			size_t nterms, Mat **qpowers ) {
	PetscErrorCode ierr;
	if ((*qpowers) != PETSC_NULL) {
		for (size_t i = 0; i < nterms; i++) {
			ierr = MatDestroy( (*qpowers) + i ); CHKERRQ(ierr);
		}
		delete [] *qpowers;
		*qpowers = PETSC_NULL;
	}

	return 1;
}



// int NCPA::EPadeSolver::build_operator_matrix_without_topography(
// 	int NZvec, double *zvec, double k0, double h2,
// 	std::complex<double> impedence_factor, std::complex<double> *n, size_t nqp,
// 	int boundary_index, Mat *q ) {
// @todo update header
int NCPA::EPadeSolver::build_operator_matrix_without_topography(
	std::vector<double> &z,
	double k0, double h2, std::complex<double> impedence_factor,
	std::complex<double> *n, size_t nqp, int boundary_index, Mat *q ) {

	// Mat q;
	PetscInt Istart, Iend, col[3];
	PetscBool FirstBlock = PETSC_FALSE, LastBlock = PETSC_FALSE;
	PetscErrorCode ierr;
	PetscScalar value[3];
	PetscInt i;
	int NZvec = z.size();

	// Set up matrices
	ierr = MatCreateSeqAIJ( PETSC_COMM_SELF, NZvec, NZvec, 3, NULL, q );CHKERRQ(ierr);
	ierr = MatSetFromOptions( *q );CHKERRQ(ierr);

	// populate
	std::complex<double> bnd_cnd =
		(impedence_factor * std::sqrt( h2 ) - 1.0) / h2;
	double k02 = k0*k0;

	ierr = MatGetOwnershipRange(*q,&Istart,&Iend);CHKERRQ(ierr);
	if (Istart==0) FirstBlock=PETSC_TRUE;
    if (Iend==NZvec) LastBlock=PETSC_TRUE;
    value[0]=1.0 / h2 / k02; value[2]=1.0 / h2 / k02;
    for( i=(FirstBlock? Istart+1: Istart); i<(LastBlock? Iend-1: Iend); i++ ) {
    		if (i < boundary_index)  {
    			value[ 0 ] = 0.0;
    			value[ 1 ] = 0.0;
    			value[ 2 ] = 0.0;
    		} else if (i == boundary_index) {
    			value[ 0 ] = 0.0;
    			value[ 1 ] = bnd_cnd/k02 + (n[i]*n[i] - 1);
    			value[ 2 ] = 1.0 / h2 / k02;
    		} else {
    			value[ 0 ] = 1.0 / h2 / k02;
    			value[ 1 ] = -2.0 / h2 / k02 + (n[i]*n[i] - 1);
    			value[ 2 ] = 1.0 / h2 / k02;
    		}
		    col[0]=i-1; col[1]=i; col[2]=i+1;
		    ierr = MatSetValues(*q,1,&i,3,col,value,INSERT_VALUES);CHKERRQ(ierr);
    }
    if (LastBlock) {
		    i=NZvec-1; col[0]=NZvec-2; col[1]=NZvec-1;
		    value[ 0 ] = 1.0 / h2 / k02;
		    value[ 1 ] = -2.0/h2/k02 + (n[i]*n[i] - 1);
		    ierr = MatSetValues(*q,1,&i,2,col,value,INSERT_VALUES);CHKERRQ(ierr);
    }
    if (FirstBlock) {
		    i=0; col[0]=0; col[1]=1;
		    if (i < boundary_index)  {
    			value[ 0 ] = 0.0;
    			value[ 1 ] = 0.0;
    		} else {
    			value[ 0 ] = bnd_cnd/k02 + (n[i]*n[i] - 1);
    			value[ 1 ] = 1.0 / h2 / k02;
    		}
		    ierr = MatSetValues(*q,1,&i,2,col,value,INSERT_VALUES);CHKERRQ(ierr);
    }
    ierr = MatAssemblyBegin(*q,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);
    ierr = MatAssemblyEnd(*q,MAT_FINAL_ASSEMBLY);CHKERRQ(ierr);

    return 1;
}



void NCPA::EPadeSolver::setup_turbulence(std::vector<double> &rand1,
		std::vector<double> &rand2 ) {
	if (use_random_turbulence_) {
		rand1 = NCPA::random_numbers( nturbulence_ );
		rand2 = NCPA::random_numbers( nturbulence_ );
	} // otherwise they're already precalculated
	turbulence_ = new NCPA::Turbulence( nturbulence_ );
	turbulence_->set_turbulence_scale( turbulence_scale_.get() );
	turbulence_->set_temperature_factor( turbulence_t_factor_ );
	turbulence_->set_velocity_factor( turbulence_v_factor_ );
	turbulence_->set_wavenumbers_log( turbulence_k1_,
		turbulence_k2_ );
	turbulence_->compute_phases( rand1 );
	turbulence_->compute();
	turbulence_->set_alpha( rand2 );

	t_vec1_   = gsl_vector_alloc( nturbulence_ );
	t_vec_mu_ = gsl_vector_alloc( z_vector_.size() );
	t_mat1_   = gsl_matrix_alloc( z_vector_.size(), nturbulence_ );

}

void NCPA::EPadeSolver::cleanup_turbulence() {
	delete turbulence_;

	gsl_vector_free( t_vec1_ );
	gsl_vector_free( t_vec_mu_ );
	gsl_matrix_free( t_mat1_ );
}

// Calculate and return k0, c0, c, a, k, and n
// void NCPA::EPadeSolver::calculate_atmosphere_parameters(
// 	NCPA::Atmosphere2D *atm, int NZvec, double *z_vec, double r, double z_g,
// 	bool use_lossless, bool use_top_layer, double freq, bool absolute,
// 	double &k0, double &c0, double *c_vec, double *a_vec,
// 	std::complex<double> *k_vec, std::complex<double> *n_vec ) {
// @todo update header
void NCPA::EPadeSolver::calculate_atmosphere_parameters(
	std::vector<double> &z, double r, double z_g, bool absolute,
	double &k0, double &c0, double *c_vec, double *a_vec,
	std::complex<double> *k_vec, std::complex<double> *n_vec ) {

	std::complex<double> I( 0.0, 1.0 );
	size_t NZvec = z.size();

	std::memset( c_vec, 0, NZvec * sizeof(double) );
	std::memset( a_vec, 0, NZvec * sizeof(double) );
	std::memset( k_vec, 0, NZvec * sizeof( std::complex< double > ) );
	std::memset( n_vec, 0, NZvec * sizeof( std::complex< double > ) );

	// z_vec is relative to ground
	if (absolute) {
		this->fill_atm_vector_absolute( r, "_CEFF_", c_underground, c_vec );
	} else {
		this->fill_atm_vector_relative( r, "_CEFF_", z_g, c_vec );
	}
	c0 = atm_profile_2d_->get( r, "_CEFF_", z_g );

	if (!lossless_) {
		if (absolute) {
			this->fill_atm_vector_absolute( r, "_ALPHA_", 0.0, a_vec );
		} else {
			this->fill_atm_vector_relative( r, "_ALPHA_", z_g, a_vec );
		}
	}
	double *abslayer = NCPA::zeros<double>( NZvec );
	if (toplayer_) {
		this->absorption_layer( c0 / freq, abslayer );
	}

	k0 = 2.0 * PI * freq_ / c0;

	// Set up arrays
	for (size_t i = 0; i < NZvec; i++) {
		double rho, drho, ddrho;
		if (absolute && (z[i] < z_g)) {
			k_vec[ i ] = 0.0;    // k == 0 below the ground
		} else {
			rho = atm_profile_2d_->get( r, "RHO", z[ i ] );
			drho = atm_profile_2d_->get_first_derivative(
				r, "RHO", z[ i ] );
			ddrho = atm_profile_2d_->get_second_derivative(
				r, "RHO", z[ i ] );
			k_vec[ i ] = std::sqrt(
							std::pow( 2.0 * PI * freq_ / c_vec[ i ], 2.0 )
							- 0.75 * std::pow( drho / rho, 2.0 )
							+ 0.5 * ddrho / rho
						) + (a_vec[ i ] + abslayer[ i ]) * I;
		}
		n_vec[ i ] = k_vec[ i ] / k0;
	}
}

// void NCPA::EPadeSolver::fill_atm_vector_absolute( NCPA::Atmosphere2D *atm, double range, int NZvec, double *zvec,
// 	std::string key, double fill_value, double *vec ) {
// @todo update header
void NCPA::EPadeSolver::fill_atm_vector_absolute( double range,
	std::string key, double fill_value, double *vec ) {

	double zmin = atm_profile_2d_->get_interpolated_ground_elevation( range );
	size_t NZvec = z_vector_.size();

	for (int i = 0; i < NZvec; i++) {
		if (z_vector_[i] < zmin) {
			vec[i] = fill_value;
		} else {
			vec[i] = atm_profile_2d_->get( range, key, z_vector_[i] );
		}
	}
}

// void NCPA::EPadeSolver::fill_atm_vector_relative( NCPA::Atmosphere2D *atm, double range, int NZvec, double *zvec,
// 	std::string key, double groundheight, double *vec ) {
// @todo update header
void NCPA::EPadeSolver::fill_atm_vector_relative( double range,
	std::string key, double groundheight, double *vec ) {

	size_t NZvec = z_vector_.size();
	for (int i = 0; i < NZvec; i++) {
		vec[i] = atm_profile_2d_->get( range, key,
			z_vector_[i] + groundheight );
	}
}

// void NCPA::EPadeSolver::absorption_layer( double lambda, double *z, int NZ,
// 	double *layer ) {
// @todo update header
void NCPA::EPadeSolver::absorption_layer( double lambda, double *layer ) {

	double thickness = NCPA::min<double>(
		NCPAPROP_EPADE_PE_ABSORBING_LAYER_MAX_THICKNESS_METERS,
		lambda * NCPAPROP_EPADE_PE_ABSORBING_LAYER_WAVELENGTH_MULTIPLIER );
	double z_t = z_vector_.back() - thickness;
	size_t NZ = z_vector_.size();
	for (size_t i = 0; i < NZ; i++) {
		layer[ i ] = absorption_layer_mu *
				std::exp( (z_vector_[i]-z_t) / thickness );
	}
}

// void NCPA::EPadeSolver::calculate_turbulence( double r,
// 		size_t nz, double *z, double k_a, size_t ground_index,
// 		double *&mu ) const {
// @todo update header
void NCPA::EPadeSolver::calculate_turbulence( double r,
		double k_a, size_t ground_index, double *&mu ) const {

	size_t i, j, nt, nz;
	nt = turbulence_->size();
	nz = z_vector_->size();

	gsl_vector_set_zero( t_vec1_ );
	gsl_vector_set_zero( t_vec_mu_ );
	gsl_matrix_set_zero( t_mat1_ );

	for (i = 0; i < nt; i++) {
		// vec1->set( 0, i, turbulence->get_G( i ) );
		gsl_vector_set( t_vec1_, i, turbulence_->get_G( i ) );
		for (j = 0; j < nz; j++) {
			double temp = r * turbulence_->get_k( i ).real()
						+ turbulence_->get_alpha( i )
						+ turbulence_->get_k( i ).imag() * z_vector_[ j ];
			gsl_matrix_set( t_mat1_, j, i, std::cos( temp ) );
			// mat1->set( i, j, std::cos( temp ) );
			// ofs << i << " " << j << " " << mat1->get( i, j ) << std::endl;
		}
	}

	gsl_blas_dgemv( CblasNoTrans, 1.0, t_mat1_, t_vec1_, 0.0, t_vec_mu_ );
	for (j = 0; j < nz; j++) {
		if (j >= ground_index) {
			mu[ j ] = gsl_vector_get( t_vec_mu_, j );
		} else {
			mu[ j ] = 0.0;
		}
	}
}




























// all the boring getter/setter methods here

// Maximum range (internally stored in meters)
double NCPA::EPadeSolver::getMaximumRange() const {
	return r_max_.get();
}

NCPA::units_t NCPA::EPadeSolver::getMaximumRangeUnits() const {
	return r_max_.get_units();
}

void NCPA::EPadeSolver::getMaximumRange( double &r, units_t &u ) const {
	r = getMaximumRange();
	u = getMaximumRangeUnits();
}

void NCPA::EPadeSolver::setMaximumRange( double r, NCPA::units_t u ) {
	//r_max = NCPA::Units::convert( r, u, NCPA::UNITS_DISTANCE_METERS );
	r_max_.set( r, u );
}

// Maximum height (stored internally in meters)
double NCPA::EPadeSolver::getMaximumHeight() const {
	return r_max_.get();
}

NCPA::units_t NCPA::EPadeSolver::getMaximumHeightUnits() const {
	return r_max_.get_units();
}

void NCPA::EPadeSolver::getMaximumHeight( double &r, units_t &u ) const {
	r = getMaximumHeight();
	u = getMaximumHeightUnits();
}

void NCPA::EPadeSolver::setMaximumHeight( double r, NCPA::units_t u ) {
	z_max_.set( r, u );
	user_max_height_used_ = true;
}

// Source height (stored internally in meters)
double NCPA::EPadeSolver::getSourceHeight() const {
	return z_source_.get();
}

NCPA::units_t NCPA::EPadeSolver::getSourceHeightUnits() const {
	return z_source_.get_units();
}

void NCPA::EPadeSolver::getSourceHeight( double &r, units_t &u ) const {
	r = getSourceHeight();
	u = getSourceHeightUnits();
}

void NCPA::EPadeSolver::setSourceHeight( double r, NCPA::units_t u ) {
	z_source_.set( r, u );
	user_source_height_used_ = true;
}

// Receiver height (stored internally in meters)
double NCPA::EPadeSolver::getReceiverHeight() const {
	return z_receiver_.get();
}

NCPA::units_t NCPA::EPadeSolver::getReceiverHeightUnits() const {
	return z_receiver_.get_units();
}

void NCPA::EPadeSolver::getReceiverHeight( double &r, units_t &u ) const {
	r = getReceiverHeight();
	u = getReceiverHeightUnits();
}

void NCPA::EPadeSolver::setReceiverHeight( double r, NCPA::units_t u ) {
	z_receiver_.set( r, u );
	user_receiver_height_used_ = true;
}

// Height resolution (stored internally in meters)
double NCPA::EPadeSolver::getHeightResolution() const {
	return dz_.get();
}

NCPA::units_t NCPA::EPadeSolver::getHeightResolutionUnits() const {
	return dz_.get_units();
}

void NCPA::EPadeSolver::getHeightResolution( double &r, units_t &u ) const {
	r = getHeightResolution();
	u = getHeightResolutionUnits();
}

void NCPA::EPadeSolver::setHeightResolution( double r, NCPA::units_t u ) {
	dz_.set( r, u );
	user_dz_used_ = true;
}

// range steps
size_t NCPA::EPadeSolver::getRangeSteps() const {
	return nr_;
}

void NCPA::EPadeSolver::setRangeSteps( size_t nr ) {
	user_nr_ = nr;
}

// Pade order
size_t NCPA::EPadeSolver::getPadeOrder() const {
	return npade_;
}

void NCPA::EPadeSolver::setPadeOrder( size_t np ) {
	npade_ = np;
}

// ground impedence
std::complex<double> NCPA::EPadeSolver::getUserGroundImpedence() const {
	if (user_ground_impedence_found) {
		return user_ground_impedence;
	} else {
		return 0.0;
	}
}

void NCPA::EPadeSolver::setUserGroundImpedence( std::complex<double> imp ) {
	user_ground_impedence_ = imp;
	user_ground_impedence_used_ = true;
}

void NCPA::EPadeSolver::setUserGroundImpedence( double re, double im ) {
	user_ground_impedence_.real( re );
	user_ground_impedence_.imag( im );
	user_ground_impedence_used_ = true;
}

NCPA::StarterType NCPA::EPadeSolver::getStarterType() const {
	return starter_type_;
}

void NCPA::EPadeSolver::setStarterType( NCPA::StarterType s ) {
	starter_type_ = s;
}

std::string NCPA::EPadeSolver::getFileTag() const {
	std::string s( user_tag );
	return s;
}

void NCPA::EPadeSolver::setFileTag( const std::string &s ) {
	user_tag = s;
}

NCPA::AtmosphereType NCPA::EPadeSolver::getAtmosphereType() const {
	return atmosphere_type_;  // move this to inside the atmosphere object
}

std::string NCPA::EPadeSolver::getAtmosphereFileName() const {
	std::string s = atmosphere_file_name_;
	return s;
}

std::string NCPA::EPadeSolver::getAtmosphereHeaderFileName() const {
	std::string s = atmosphere_header_file_name_;
	return s;
}

void NCPA::EPadeSolver::setAtmosphere(
		NCPA::AtmosphereType atmostype,
		const std::string &atmosfile,
		const std::string &headerfile ) {

	atmosphere_type_ = atmostype;
	atmosphere_file_name_ = atmosfile;
	atmosphere_header_file_name_ = headerfile;
}

void NCPA::EPadeSolver::setTurbulence( NCPA::Turbulence *turb ) {
	turbulence = new NCPA::Turbulence( *turb );
	use_turbulence_ = true;
}

NCPA::Turbulence * NCPA::EPadeSolver::getTurbulence() const {
	return turbulence;
}

std::vector<double> NCPA::EPadeSolver::getAzimuthVector() const {
	std::vector<double> azvec = azimuth_vector_;
	return azvec;
}

double NCPA::EPadeSolver::getAzimuth() const {
	return azimuth_vector_[ 0 ];
}

void NCPA::EPadeSolver::setAzimuth( const std::vector<double> &azvec ) {
	azimuth_vector_ = azvec;
}

void NCPA::EPadeSolver::setAzimuth( double d ) {
	azimuth_vector_.clear();
	azimuth_vector_.push_back( d );
}

std::vector<double> NCPA::EPadeSolver::getFrequencyVector() const {
	std::vector<double> fvec = frequency_vector_;
	return fvec;
}

double NCPA::EPadeSolver::getFrequency() const {
	return frequency_vector_[ 0 ];
}

void NCPA::EPadeSolver::setFrequency( const std::vector<double> &fvec ) {
	frequency_vector_ = fvec;
}

void NCPA::EPadeSolver::setFrequency( double d ) {
	frequency_vector_.clear();
	frequency_vector_.push_back( d );
}

bool NCPA::EPadeSolver::getLossless() const { return lossless_; }
void NCPA::EPadeSolver::setLossless( bool tf ) { lossless_ = tf; }

bool NCPA::EPadeSolver::getUseTopLayer() const { return toplayer_; }
void NCPA::EPadeSolver::setUseTopLayer( bool tf ) { toplayer_ = tf; }

bool NCPA::EPadeSolver::getUseTopography() const { return topo_; }
void NCPA::EPadeSolver::setUseTopography( bool tf ) { topo_ = tf; }

bool NCPA::EPadeSolver::getMultiprop() const {
	return (azimuth_vector_.size() > 1);
}

bool NCPA::EPadeSolver::getBroadband() const {
	return (frequency_vector_.size() > 1);
}

bool NCPA::EPadeSolver::getUserGroundHeightUsed() const {
	return user_ground_height_used_;
}

bool NCPA::EPadeSolver::getUserSourceHeightUsed() const {
	return user_source_height_used_;
}

bool NCPA::EPadeSolver::getUserReceiverHeightUsed() const {
	return user_receiver_height_used_;
}

bool NCPA::EPadeSolver::getUseTurbulence() const { return use_turbulence_; }
void NCPA::EPadeSolver::setUseTurbulence( bool tf ) { use_turbulence_ = tf; }

bool NCPA::EPadeSolver::getWrite2DTransmissionLoss() const { return write2d_; }
void NCPA::EPadeSolver::setWrite2DTransmissionLoss( bool tf ) { write2d_ = tf; }

bool NCPA::EPadeSolver::getWriteStarter() const { return write_starter_; }
void NCPA::EPadeSolver::setWriteStarter( bool tf ) { write_starter_ = tf; }

bool NCPA::EPadeSolver::getWriteTopography() const { return write_topography_; }
void NCPA::EPadeSolver::setWriteTopography( bool tf ) { write_topography_ = tf; }

bool NCPA::EPadeSolver::getWriteAtmosphere() const { return write_atmosphere_; }
void NCPA::EPadeSolver::setWriteAtmosphere( bool tf ) { write_atmosphere_ = tf; }

bool NCPA::EPadeSolver::getUserAttenuationUsed() const { return user_attenuation_; }
void NCPA::EPadeSolver::setUserAttenuationUsed( bool tf ) { user_attenuation_ = tf; }

// turbulence
void NCPA::EPadeSolver::setTurbulenceScale( double scale, units_t u ) {
	turbulence_scale_.set( scale, u );
}

void NCPA::EPadeSolver::setTurbulenceSpectrumSize( size_t n ) {
	nturbulence_ = n;
}

void NCPA::EPadeSolver::setTurbulenceTemperatureFactor( double d ) {
	turbulence_t_factor_ = d;
}

void NCPA::EPadeSolver::setTurbulenceVelocityFactor( double d ) {
	turbulence_v_factor_ = d;
}

void NCPA::EPadeSolver::setTurbulenceFileName( const std::string &s ) {
	turbulence_file_ = s;
	use_random_turbulence_ = (s.size() > 1);

}

double NCPA::EPadeSolver::getTurbulenceScale() const {
	return turbulence_scale_.get();
}

units_t NCPA::EPadeSolver::getTurbulenceScaleUnits() const {
	return turbulence_scale_.get_units();
}

size_t NCPA::EPadeSolver::getTurbulenceSpectrumSize() const {
	return nturbulence_;
}

double NCPA::EPadeSolver::getTurbulenceTemperatureFactor() const {
	return turbulence_t_factor_;
}

double NCPA::EPadeSolver::getTurbulenceVelocityFactor() const {
	return turbulence_v_factor_;
}

std::string NCPA::EPadeSolver::getTurbulenceFileName() const {
	std::string s( turbulence_file_ );
	return s;
}

bool NCPA::EPadeSolver::getUseRandomTurbulence() const {
	return use_random_turbulence_;
}

void NCPA::EPadeSolver::setUseRandomTurbulence( bool tf ) {
	use_random_turbulence_ = tf;
}

std::string NCPA::EPadeSolver::getStarterFileName() const {
	std::string s(user_starter_file_);
	return s;
}

void NCPA::EPadeSolver::setStarterFileName( const std::string &filename ) {
	user_starter_file_ = filename;
}

std::string NCPA::EPadeSolver::getTopographyFileName() const {
	std::string s(topography_file_);
	return s;
}

void NCPA::EPadeSolver::setTopographyFileName( const std::string &filename ) {
	topography_file_ = filename;
}

std::string NCPA::EPadeSolver::getAttenuationFileName() const {
	std::string s(attenuation_file_);
	return s;
}

void NCPA::EPadeSolver::setAttenuationFileName( const std::string &filename ) {
	attenuation_file_ = filename;
}

double NCPA::EPadeSolver::getUserGroundHeight() const {
	return user_z_ground_.get();
}

NCPA::units_t NCPA::EPadeSolver::getUserGroundHeightUnits() const {
	return user_z_ground_.get_units();
}

void NCPA::EPadeSolver::getUserGroundHeight( double &z, NCPA::units_t &u ) const {
	z = getUserGroundHeight();
	u = getUserGroundHeightUnits();
}

void NCPA::EPadeSolver::setUserGroundHeight( double zg, NCPA::units_t u ) {
	user_z_ground_.set( zg, u );
	user_ground_height_used_ = true;
}

void checkfile_( const std::string &filename ) {
	std::ostringstream oss;
	if (!((filename.size() > 0) && NCPA::fexists( filename ))) {
		oss << "File " << filename << " is not readable!";
		throw std::runtime_error( oss.str() );
	}
}

void checktrue_( bool tf, const std::string &message ) {
	if (!tf) {
		throw std::runtime_error( message );
	}
}

std::string NCPA::EPadeSolver::tag_filename( std::string basename ) {
	return user_tag_ + basename;
}

/*
Broadband body format:
foreach (az)
  foreach (freq)
    int64_t  az                       * precision_factor
    int64_t  freq                     * precision_factor
    uint32_t n_z
    uint32_t n_range
    int64_t  z[ 0 ]                   * precision_factor
      ...
    int64_t  z[ n_z-1 ]               * precision_factor
    int64_t  range[ 0 ]               * precision_factor
      ...
    int64_t  range[ n_range-1 ]       * precision_factor
    int64_t  Re{ TL[ z[0] ][ r[0] ] } * precision_factor
	int64_t  Im{ TL[ z[0] ][ r[0] ] } * precision_factor
	int64_t  Re{ TL[ z[0] ][ r[1] ] } * precision_factor
	int64_t  Im{ TL[ z[0] ][ r[1] ] } * precision_factor
	  ...
	int64_t  Re{ TL[ z[0] ][ r[n_range-1] ] } * precision_factor
	int64_t  Im{ TL[ z[0] ][ r[n_range-1] ] } * precision_factor
	int64_t  Re{ TL[ z[1] ][ r[0] ] } * precision_factor
	int64_t  Im{ TL[ z[1] ][ r[0] ] } * precision_factor
	int64_t  Re{ TL[ z[1] ][ r[1] ] } * precision_factor
	int64_t  Im{ TL[ z[1] ][ r[1] ] } * precision_factor
	  ...

	We use an integer precision factor so that we can store in integer
	form with fixed precision, then transform back to double on read.
*/
// @todo update header
void NCPA::EPadeSolver::write_broadband_results( std::string filename,
	unsigned int precision_factor ) {

	size_t n_r = nr_ - 1;    // last range step is invalid
	size_t n_z = z_vector_.size();
	double dpf = (double)precision_factor;

	std::ofstream ofs( filename,
		std::ofstream::out | std::ofstream::app | std::ofstream::binary );
	if (!ofs.good()) {
		throw std::runtime_error( "Error opening file to append: "
			+ filename );
	}

	// write az, freq, n_z, n_range
	int64_t holder = (int64_t)std::lround( calc_az_ * dpf );
	ofs.write( (char*)(&holder), sizeof( int64_t ) );
	holder = (int64_t)std::lround( freq_ * dpf );
	ofs.write( (char*)(&holder), sizeof( int64_t ) );
	uint32_t uholder = (uint32_t)n_z;
	ofs.write( (char*)(&uholder), sizeof( uint32_t ) );
	uholder = (uint32_t)n_r;
	ofs.write( (char*)(&uholder), sizeof( uint32_t ) );

	// z and r sizes and vectors
	size_t buf_size = n_r;
	if (n_z > buf_size) {
		buf_size = n_z;
	}
	int64_t *buffer = new int64_t[ buf_size ];
	std::memset( buffer, 0, buf_size * sizeof( int64_t ) );
	size_t i, j;
	for (i = 0; i < n_z; i++) {
		buffer[ i ] = (int64_t)std::lround( z_vector_[ i ] * dpf );
	}
	ofs.write( (char*)buffer, n_z * sizeof( int64_t ) );
	for (i = 0; i < n_r; i++) {
		buffer[ i ] = (int64_t)std::lround( r_vec[ i ] * dpf );
	}
	ofs.write( (char*)buffer, n_r * sizeof( int64_t ) );
	for (i = 0; i < n_z; i++) {
		for (j = 0; j < n_r; j++) {
			holder = (int64_t)std::lround( tloss_[ i ][ j ].real() * dpf );
			ofs.write( (char *)(&holder), sizeof( int64_t ) );
			holder = (int64_t)std::lround( tloss_[ i ][ j ].imag() * dpf );
			ofs.write( (char *)(&holder), sizeof( int64_t ) );
		}
	}
	ofs.close();
	delete [] buffer;
}

// @todo update header
void NCPA::EPadeSolver::calculate_effective_sound_speed(
	double az, const std::string &new_key ) {

	// first: was it given explicitly using column "CEFF"?
	if (atm_profile_2d_->contains_vector( 0.0, "CEFF" )) {
		atm_profile_2d_->convert_property_units( "CEFF", Units::fromString( "m/s" ) );
		atm_profile_2d_->copy_vector_property( "CEFF", new_key );

	// do we have the wind speed and direction?
	} else if (atm_profile_2d_->contains_vector( 0.0, "_WS_")
		&& atm_profile_2d_->contains_vector( 0.0, "_WD_") ) {
		atm_profile_2d_->calculate_wind_component( "_WC_", "_WS_", "_WD_", az );
		atm_profile_2d_->calculate_effective_sound_speed( "_CEFF_", "_C0_", "_WC_" );
		atm_profile_2d_->remove_property( "_WC_" );
	} else {
		std::ostringstream oss;
		oss << "Cannot calculate effective sound speed, necessary components not found."
			<< std::endl
			<< "Input atmosphere must have one of:" << std::endl
			<< "  CEFF column, or" << std::endl
			<< "  WS and WD columns for wind speed and direction, or" << std::endl
			<< "  U and V columns for zonal and meridional wind vectors." << std::endl;

		throw std::runtime_error( oss.str() );
	}
}